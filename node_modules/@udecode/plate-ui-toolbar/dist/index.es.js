import _styled, { css } from 'styled-components';
import React, { useState, useEffect } from 'react';
import { plateButtonCss } from '@udecode/plate-ui-button';
import { createStyles, PortalBody } from '@udecode/plate-styled-components';
import { useEventEditorSelectors, usePlateEditorState, isSelectionExpanded, getSelectionText, mergeProps, useEventPlateId, someNode, toggleNodeType, focusEditor, isMarkActive, toggleMark } from '@udecode/plate-common';
import { useVirtualFloating, offset, flip, getSelectionBoundingClientRect, useFloating } from '@udecode/plate-floating';
import { useFocused } from 'slate-react';
import Tippy from '@tippyjs/react';

const FloatingVerticalDivider = () => /*#__PURE__*/React.createElement(_StyledDiv$1, null);

var _StyledDiv$1 = _styled("div").withConfig({
  displayName: "FloatingVerticalDivider___StyledDiv",
  componentId: "sc-17bdbkd-0"
})({
  "marginLeft": "0.5rem",
  "marginRight": "0.5rem",
  "height": "1.25rem",
  "width": "1px",
  "--tw-bg-opacity": "1",
  "backgroundColor": "rgb(229 231 235 / var(--tw-bg-opacity))"
});

const floatingRootCss = css(["", ";border-radius:4px;box-shadow:rgb(15 15 15 / 5%) 0 0 0 1px,rgb(15 15 15 / 10%) 0 3px 6px,rgb(15 15 15 / 20%) 0 9px 24px;"], {
  "zIndex": "40 !important",
  "width": "auto",
  "--tw-bg-opacity": "1",
  "backgroundColor": "rgb(255 255 255 / var(--tw-bg-opacity))"
});
const floatingRowCss = css(["", ";"], {
  "display": "flex",
  "flexDirection": "row",
  "alignItems": "center",
  "paddingLeft": "0.5rem",
  "paddingRight": "0.5rem",
  "paddingTop": "0.25rem",
  "paddingBottom": "0.25rem"
});
const floatingButtonCss = [...plateButtonCss, {
  "paddingLeft": "0.25rem",
  "paddingRight": "0.25rem"
}];
const FloatingIconWrapper = _styled.div.withConfig({
  displayName: "styles__FloatingIconWrapper",
  componentId: "sc-zqwbtz-0"
})(["", ";"], {
  "display": "flex",
  "alignItems": "center",
  "paddingLeft": "0.5rem",
  "paddingRight": "0.5rem",
  "--tw-text-opacity": "1",
  "color": "rgb(156 163 175 / var(--tw-text-opacity))"
});
const FloatingInputWrapper = _styled.div.withConfig({
  displayName: "styles__FloatingInputWrapper",
  componentId: "sc-zqwbtz-1"
})(["", ";"], {
  "display": "flex",
  "alignItems": "center",
  "paddingTop": "0.25rem",
  "paddingBottom": "0.25rem",
  "paddingRight": "0.5rem"
});
const floatingInputCss = [{
  "height": "2rem",
  "flexGrow": "1",
  "borderStyle": "none",
  "backgroundColor": "transparent",
  "padding": "0px"
}, {
  ":focus": {
    "outline": "2px solid transparent",
    "outlineOffset": "2px"
  }
}, css(["line-height:20px;"])];

const getToolbarStyles = props => createStyles({
  prefixClassNames: 'Toolbar',
  ...props
}, {
  root: [{
    "boxSizing": "content-box",
    "display": "flex",
    "userSelect": "none",
    "alignItems": "center"
  }, {
    "minHeight": "40px",
    "--tw-text-opacity": "1",
    "color": "rgb(68 68 68 / var(--tw-text-opacity))"
  }]
});

const getBalloonToolbarStyles = props => {
  let color = 'rgb(157, 170, 182)';
  let colorActive = 'white';
  let background = 'rgb(36, 42, 49)';
  let borderColor = 'transparent';

  if (props.theme === 'light') {
    color = 'rgba(0, 0, 0, 0.50)';
    colorActive = 'black';
    background = 'rgb(250, 250, 250)';
    borderColor = 'rgb(196, 196, 196)';
  }

  const {
    placement = 'top'
  } = props;
  const arrowStyle = [props.arrow && css(["::after{left:50%;content:' ';position:absolute;margin-top:-1px;transform:translateX(-50%);border-color:", " transparent;border-style:solid;}"], background), props.arrow && placement.includes('top') && css(["::after{top:100%;bottom:auto;border-width:8px 8px 0;}"]), props.arrow && !placement.includes('top') && css(["::after{top:auto;bottom:100%;border-width:0 8px 8px;}"])];
  const arrowBorderStyle = [props.arrow && placement.includes('top') && props.theme === 'light' && css(["::before{margin-top:0;border-width:9px 9px 0;border-color:", " transparent;}"], borderColor), props.arrow && !placement.includes('top') && props.theme === 'light' && css(["::before{margin-top:0;border-width:0 9px 9px;border-color:", " transparent;}"], borderColor)];
  return createStyles({
    prefixClassNames: 'BalloonToolbar',
    ...props
  }, {
    root: [...getToolbarStyles(props).root.css, {
      "position": "absolute",
      "whiteSpace": "nowrap",
      "opacity": "1",
      "transitionProperty": "opacity .2s ease-in-out",
      "transitionTimingFunction": "cubic-bezier(0.4, 0, 0.2, 1)",
      "transitionDuration": "150ms"
    }, css(["color:", ";background:", ";z-index:500;border:1px solid ", ";border-radius:4px;.slate-ToolbarButton-active,.slate-ToolbarButton:hover{color:", ";}::before{", "}"], color, background, borderColor, colorActive, arrowBorderStyle), ...arrowStyle, ...arrowBorderStyle]
  });
};

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends.apply(this, arguments);
}

const ToolbarBase = /*#__PURE__*/React.forwardRef((props, ref) => {
  return /*#__PURE__*/React.createElement("div", _extends({
    "data-testid": "Toolbar",
    ref: ref
  }, props));
});

var _StyledToolbarBase$2 = _styled(ToolbarBase).withConfig({
  displayName: "Toolbar___StyledToolbarBase",
  componentId: "sc-1srlh8g-0"
})(["", ""], p => p.$_css);

const Toolbar = /*#__PURE__*/React.forwardRef((props, ref) => {
  const {
    root
  } = getToolbarStyles(props);
  return /*#__PURE__*/React.createElement(_StyledToolbarBase$2, _extends({}, props, {
    ref: ref,
    className: root.className,
    $_css: root.css
  }));
});

const useFloatingToolbar = ({
  floatingOptions,
  ignoreReadOnly = false,
  hideToolbar = false
} = {}) => {
  var _selectionText$length;

  const focusedEditorId = useEventEditorSelectors.focus();
  const editor = usePlateEditorState();
  const focused = useFocused();
  const [waitForCollapsedSelection, setWaitForCollapsedSelection] = useState(false);
  const [open, setOpen] = useState(false);
  const selectionExpanded = editor && isSelectionExpanded(editor);
  const selectionText = editor && getSelectionText(editor); // On refocus, the editor keeps the previous selection,
  // so we need to wait it's collapsed at the new position before displaying the floating toolbar.

  useEffect(() => {
    if (!focused || ignoreReadOnly) {
      setWaitForCollapsedSelection(true);
    }

    if (!selectionExpanded) {
      setWaitForCollapsedSelection(false);
    }
  }, [focused, ignoreReadOnly, selectionExpanded]);
  useEffect(() => {
    if (!selectionExpanded || !selectionText || !(editor.id === focusedEditorId || ignoreReadOnly) && hideToolbar) {
      setOpen(false);
    } else if (selectionText && selectionExpanded && !waitForCollapsedSelection) {
      setOpen(true);
    }
  }, [editor.id, editor.selection, focusedEditorId, hideToolbar, ignoreReadOnly, selectionExpanded, selectionText, waitForCollapsedSelection]);
  const floatingResult = useVirtualFloating(mergeProps({
    middleware: [offset(12), flip({
      padding: 96
    })],
    placement: 'top',
    getBoundingClientRect: getSelectionBoundingClientRect,
    open,
    onOpenChange: setOpen
  }, floatingOptions));
  const {
    update
  } = floatingResult;
  const selectionTextLength = (_selectionText$length = selectionText === null || selectionText === void 0 ? void 0 : selectionText.length) !== null && _selectionText$length !== void 0 ? _selectionText$length : 0;
  useEffect(() => {
    if (selectionTextLength > 0) {
      update === null || update === void 0 ? void 0 : update();
    }
  }, [selectionTextLength, update]);
  return { ...floatingResult,
    open
  };
};

const BalloonToolbar = props => {
  const {
    children,
    theme = 'dark',
    arrow = false,
    portalElement,
    floatingOptions,
    ignoreReadOnly,
    hideToolbar
  } = props;
  const {
    refs,
    style,
    placement,
    open
  } = useFloatingToolbar({
    floatingOptions,
    ignoreReadOnly,
    hideToolbar
  });
  const styles = getBalloonToolbarStyles({
    placement,
    theme,
    arrow,
    ...props
  });
  if (!open) return null;
  return /*#__PURE__*/React.createElement(PortalBody, {
    element: portalElement
  }, /*#__PURE__*/React.createElement(_StyledToolbarBase$1, {
    className: styles.root.className,
    ref: refs.setFloating,
    style: style,
    $_css: styles.root.css
  }, children));
};

var _StyledToolbarBase$1 = _styled(ToolbarBase).withConfig({
  displayName: "BalloonToolbar___StyledToolbarBase",
  componentId: "sc-s0c2tw-0"
})(["", ""], p => p.$_css);

const getToolbarButtonStyles = props => {
  var _props$styles;

  return createStyles({
    prefixClassNames: 'ToolbarButton',
    ...props
  }, {
    root: [{
      "display": "flex",
      "cursor": "pointer",
      "userSelect": "none",
      "alignItems": "center",
      "justifyContent": "center",
      "verticalAlign": "middle"
    }, {
      "height": "32px",
      "width": "32px"
    }, {
      "borderStyle": "none",
      "backgroundColor": "transparent",
      "color": "currentColor",
      "outline": "2px solid transparent",
      "outlineOffset": "2px",
      ":hover": {
        "backgroundColor": "transparent"
      }
    }, css(["> svg{", "}"], {
      "display": "block",
      "height": "1.25rem",
      "width": "1.25rem"
    }), props.active && ((_props$styles = props.styles) === null || _props$styles === void 0 ? void 0 : _props$styles.active)],
    ...(props.active && {
      active: {}
    })
  });
};

function toVal(mix) {
	var k, y, str='';

	if (typeof mix === 'string' || typeof mix === 'number') {
		str += mix;
	} else if (typeof mix === 'object') {
		if (Array.isArray(mix)) {
			for (k=0; k < mix.length; k++) {
				if (mix[k]) {
					if (y = toVal(mix[k])) {
						str && (str += ' ');
						str += y;
					}
				}
			}
		} else {
			for (k in mix) {
				if (mix[k]) {
					str && (str += ' ');
					str += k;
				}
			}
		}
	}

	return str;
}

function clsx () {
	var i=0, tmp, x, str='';
	while (i < arguments.length) {
		if (tmp = arguments[i++]) {
			if (x = toVal(tmp)) {
				str && (str += ' ');
				str += x;
			}
		}
	}
	return str;
}

const ToolbarButton = props => {
  const {
    id,
    active: _active,
    icon,
    tooltip,
    className,
    actionHandler = 'onClick',
    onClick,
    ...buttonProps
  } = props;
  const tooltipProps = {
    content: '',
    offset: [0, 5],
    arrow: false,
    delay: 500,
    duration: [200, 0],
    hideOnClick: false,
    ...tooltip
  };
  const {
    root,
    active
  } = getToolbarButtonStyles(props); // this can replace onClick by onMouseDown

  buttonProps[actionHandler] = onClick;
  const button = /*#__PURE__*/React.createElement(_StyledButton, _extends({
    "data-testid": "ToolbarButton",
    type: "button",
    "aria-label": tooltipProps.content,
    className: clsx(root.className, active === null || active === void 0 ? void 0 : active.className, className)
  }, buttonProps, {
    $_css: root.css
  }), icon);
  return tooltip ? /*#__PURE__*/React.createElement(Tippy, tooltipProps, button) : button;
};

var _StyledButton = _styled("button").withConfig({
  displayName: "ToolbarButton___StyledButton",
  componentId: "sc-1rn3zj7-0"
})(["", ""], p => p.$_css);

/**
 * Toolbar button to toggle the type of elements in selection.
 */
const BlockToolbarButton = ({
  id,
  type,
  inactiveType,
  active: _active,
  ...props
}) => {
  const editor = usePlateEditorState(useEventPlateId(id));
  const active = _active !== null && _active !== void 0 ? _active : !!(editor !== null && editor !== void 0 && editor.selection) && someNode(editor, {
    match: {
      type
    }
  });
  return /*#__PURE__*/React.createElement(ToolbarButton, _extends({
    active: active,
    onClick: e => {
      e.preventDefault();
      e.stopPropagation();
      toggleNodeType(editor, {
        activeType: type,
        inactiveType
      });
      focusEditor(editor);
    }
  }, props));
};

const getHeadingToolbarStyles = props => createStyles({
  prefixClassNames: 'HeadingToolbar',
  ...props
}, [{
  root: [...getToolbarStyles(props).root.css, {
    "position": "relative",
    "marginLeft": "-1.25rem",
    "marginRight": "-1.25rem",
    "marginBottom": "1.25rem",
    "marginTop": "0px",
    "flexWrap": "wrap"
  }, css(["padding:1px 18px 17px;border-bottom:2px solid #eee;.slate-ToolbarButton-active,.slate-ToolbarButton:hover{color:#06c;}"])]
}]);

const HeadingToolbar = /*#__PURE__*/React.forwardRef((props, ref) => {
  const styles = getHeadingToolbarStyles(props);
  return /*#__PURE__*/React.createElement(_StyledToolbarBase, _extends({
    ref: ref,
    className: styles.root.className
  }, props, {
    $_css: styles.root.css
  }));
});

var _StyledToolbarBase = _styled(ToolbarBase).withConfig({
  displayName: "HeadingToolbar___StyledToolbarBase",
  componentId: "sc-1gnw7ox-0"
})(["", ""], p => p.$_css);

/**
 * Toolbar button to toggle the mark of the leaves in selection.
 */
const MarkToolbarButton = ({
  id,
  type,
  clear,
  ...props
}) => {
  const editor = usePlateEditorState(useEventPlateId(id));
  return /*#__PURE__*/React.createElement(ToolbarButton, _extends({
    active: !!(editor !== null && editor !== void 0 && editor.selection) && isMarkActive(editor, type),
    onClick: e => {
      e.preventDefault();
      e.stopPropagation();
      toggleMark(editor, {
        key: type,
        clear
      });
      focusEditor(editor);
    }
  }, props));
};

const closeAllExceptSelectedOneListener = ({
  open,
  onClose,
  refs
}) => ev => {
  if (open) {
    var _refs$reference$curre, _refs$floating$curren;

    const target = ev.target; // TS2339: Property 'contains' does not exist on type 'ReferenceType'

    if ((_refs$reference$curre = refs.reference.current) !== null && _refs$reference$curre !== void 0 && _refs$reference$curre.contains(target)) {
      return;
    }

    if ((_refs$floating$curren = refs.floating.current) !== null && _refs$floating$curren !== void 0 && _refs$floating$curren.contains(target)) {
      return;
    }

    onClose === null || onClose === void 0 ? void 0 : onClose(ev);
  }
};

const useDropdownControls = ({
  open,
  onClose
}) => {
  const floatingResult = useFloating({
    open,
    strategy: 'fixed',
    placement: 'bottom-start',
    middleware: [flip()]
  });
  const {
    x,
    y,
    refs,
    strategy
  } = floatingResult;
  useEffect(() => {
    const listener = closeAllExceptSelectedOneListener({
      open,
      onClose,
      refs
    });
    document.body.addEventListener('mousedown', listener);
    return () => {
      document.body.removeEventListener('mousedown', listener);
    };
  }, [onClose, open, refs]);
  return {
    styles: {
      position: strategy,
      top: y !== null && y !== void 0 ? y : 0,
      left: x !== null && x !== void 0 ? x : 0,
      width: 'max-content'
    },
    ...floatingResult
  };
};

const ToolbarDropdown = ({
  control,
  children,
  open,
  onOpen,
  onClose
}) => {
  const {
    styles,
    refs
  } = useDropdownControls({
    open,
    onClose
  });
  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("div", {
    ref: refs.setReference,
    onMouseDown: onOpen
  }, control), open && /*#__PURE__*/React.createElement(_StyledDiv, {
    ref: refs.setFloating,
    style: styles
  }, children));
};

var _StyledDiv = _styled("div").withConfig({
  displayName: "ToolbarDropdown___StyledDiv",
  componentId: "sc-1w3yept-0"
})(["", ""], floatingRootCss);

export { BalloonToolbar, BlockToolbarButton, FloatingIconWrapper, FloatingInputWrapper, FloatingVerticalDivider, HeadingToolbar, MarkToolbarButton, Toolbar, ToolbarBase, ToolbarButton, ToolbarDropdown, floatingButtonCss, floatingInputCss, floatingRootCss, floatingRowCss, getBalloonToolbarStyles, getHeadingToolbarStyles, getToolbarButtonStyles, getToolbarStyles, useDropdownControls, useFloatingToolbar };
//# sourceMappingURL=index.es.js.map
