{"version":3,"file":"projection.es.js","sources":["../../../../src/components/Tree/helpers/projection.ts"],"sourcesContent":["/* (c) Copyright Frontify Ltd., all rights reserved. */\n\nimport { ReactElement } from 'react';\nimport { arrayMove } from '@dnd-kit/sortable';\n\nimport { INDENTATION_WIDTH, ROOT_ID } from '../helpers';\nimport type { InternalTreeItemProps } from '../TreeItem';\n\nexport type ProjectionArgs = {\n    nodes: ReactElement<InternalTreeItemProps>[];\n    activeId: string;\n    overId: string;\n    dragOffset: number;\n};\n\nexport type Projection = {\n    depth: number;\n    maxDepth: number;\n    minDepth: number;\n    position: number;\n    type?: string;\n    accepts?: string;\n    parentId: Nullable<string>;\n    isWithinParent: boolean | undefined;\n    previousNode: Nullable<{ id: string; depth: number; accepts?: string }>;\n};\n\nconst getNodeDepth = (node: ReactElement) => {\n    return node ? node.props.level : 0;\n};\n\nconst getDragDepth = (offset: number) => {\n    return Math.round(offset / INDENTATION_WIDTH);\n};\n\nconst getNodeDepthConstraint = (node: ReactElement) => {\n    return (node?.props.levelConstraint ?? null) !== null ? node.props.levelConstraint : false;\n};\n\nconst calculateMaxDepth = (previousNode: ReactElement, nextNode: ReactElement) => {\n    const previousNodeDepth = getNodeDepth(previousNode);\n\n    if (previousNode?.props.accepts) {\n        const nextNodeDepth = getNodeDepth(nextNode);\n        return previousNodeDepth >= nextNodeDepth ? previousNodeDepth + 1 : nextNodeDepth;\n    } else {\n        return previousNodeDepth;\n    }\n};\n\nconst calculateMinDepth = (previousNode: ReactElement, nextNode: ReactElement) => {\n    const nextNodeDepth = getNodeDepth(nextNode);\n\n    if (previousNode?.props.accepts) {\n        return nextNodeDepth;\n    } else {\n        return Math.min(getNodeDepth(previousNode), nextNodeDepth);\n    }\n};\n\nexport const getProjection = ({ nodes, activeId, overId, dragOffset }: ProjectionArgs): Projection => {\n    const overNodeIndex = nodes.findIndex(({ props }) => props.id === overId);\n    const activeNodeIndex = nodes.findIndex(({ props }) => props.id === activeId);\n\n    const activeNode = nodes[activeNodeIndex];\n    const newNodes = arrayMove(nodes, activeNodeIndex, overNodeIndex);\n\n    const previousNode = newNodes[overNodeIndex - 1];\n    const nextNode = newNodes[overNodeIndex + 1];\n\n    const activeNodeDepthConstraint = getNodeDepthConstraint(activeNode);\n    const dragDepth = getDragDepth(dragOffset);\n    const projectedDepth = (activeNode?.props?.level ?? 0) + dragDepth;\n\n    const maxDepth =\n        activeNodeDepthConstraint !== false ? activeNodeDepthConstraint : calculateMaxDepth(previousNode, nextNode);\n    const minDepth =\n        activeNodeDepthConstraint !== false ? activeNodeDepthConstraint : calculateMinDepth(previousNode, nextNode);\n\n    let depth = projectedDepth || getNodeDepth(nextNode);\n    if (projectedDepth >= maxDepth) {\n        depth = maxDepth;\n    } else if (projectedDepth < minDepth) {\n        depth = minDepth;\n    }\n\n    const getParentId = () => {\n        if (depth === 0 || !previousNode) {\n            return ROOT_ID;\n        }\n\n        if (previousNode.props.parentId && depth === previousNode.props.level) {\n            return previousNode.props.parentId ?? null;\n        }\n\n        if (previousNode.props.level !== undefined && depth > previousNode.props.level) {\n            return previousNode.props.accepts\n                ? previousNode.props.id\n                : previousNode.props.parentId ?? previousNode.props.id;\n        }\n\n        const newParent = newNodes\n            .slice(0, overNodeIndex)\n            .reverse()\n            .find((item) => item.props.level === depth)?.props.parentId;\n\n        return newParent ?? null;\n    };\n\n    const getParent = (parentId: Nullable<string>) => {\n        if (!parentId) {\n            return null;\n        }\n        return nodes.find(({ props }) => props.id === parentId)?.props;\n    };\n\n    const parentId = getParentId();\n    const parent = getParent(parentId);\n\n    // whether we are moving down there is a +1 offset, unless we are in the same parent\n    const correctionDueDragDirection =\n        activeNodeIndex < overNodeIndex && activeNode.props.parentId !== parentId ? 1 : 0;\n\n    const nodesInParent = newNodes.filter(({ props }) => props.parentId === parentId);\n\n    /**\n     * To get the position the item is dropped within its parent (first match wins):\n     * - Get the index of the active item among the parent nodes\n     * - Use the 'over' item to get the position\n     * - If the over element is the parent matched set it to the top\n     * - If the item is going out:\n     *   - and up in the tree it goes to the bottom position\n     *   - if going down, to the first\n     * - if we move the item in or same depth and up it goes to the last position\n     */\n    let dropIndexInParent = nodesInParent.findIndex(({ props }) => props.id === activeId);\n    if (dropIndexInParent < 0) {\n        const overNextIndex = nodesInParent.findIndex(({ props }) => props.id === overId);\n        if (overNextIndex >= 0) {\n            dropIndexInParent = overNextIndex;\n        } else if (parentId === overId) {\n            dropIndexInParent = -1;\n        } else if (dragDepth < 0) {\n            dropIndexInParent = activeNodeIndex < overNodeIndex ? nodesInParent.length : -1;\n        } else if (activeNodeIndex >= overNodeIndex) {\n            dropIndexInParent = nodesInParent.length;\n        }\n    }\n\n    dropIndexInParent = dropIndexInParent + correctionDueDragDirection;\n    const parentDepth = parent?.level ?? 0;\n\n    return {\n        depth,\n        maxDepth,\n        minDepth,\n        parentId: parentId ?? null,\n        type: parent?.type,\n        accepts: parent?.accepts,\n        position: dropIndexInParent >= 0 ? dropIndexInParent : 0,\n        isWithinParent: parentDepth ? depth > parentDepth : false,\n        previousNode: previousNode\n            ? {\n                  id: previousNode.props.id,\n                  depth: getNodeDepth(previousNode),\n                  accepts: previousNode.props.accepts,\n              }\n            : null,\n    };\n};\n"],"names":["getNodeDepth","node","getDragDepth","offset","INDENTATION_WIDTH","getNodeDepthConstraint","calculateMaxDepth","previousNode","nextNode","previousNodeDepth","nextNodeDepth","calculateMinDepth","getProjection","nodes","activeId","overId","dragOffset","overNodeIndex","props","activeNodeIndex","activeNode","newNodes","arrayMove","activeNodeDepthConstraint","dragDepth","projectedDepth","_a","maxDepth","minDepth","depth","getParentId","ROOT_ID","item","getParent","parentId","parent","correctionDueDragDirection","nodesInParent","dropIndexInParent","overNextIndex","parentDepth"],"mappings":"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"}