import { arrayMove as j } from "@dnd-kit/sortable";
import { ROOT_ID as W, INDENTATION_WIDTH as _ } from "./constants.es.js";
const a = (t) => t ? t.props.level : 0, A = (t) => Math.round(t / _), E = (t) => ((t == null ? void 0 : t.props.levelConstraint) ?? null) !== null ? t.props.levelConstraint : !1, H = (t, i) => {
  const r = a(t);
  if (t != null && t.props.accepts) {
    const D = a(i);
    return r >= D ? r + 1 : D;
  } else
    return r;
}, R = (t, i) => {
  const r = a(i);
  return t != null && t.props.accepts ? r : Math.min(a(t), r);
}, q = ({ nodes: t, activeId: i, overId: r, dragOffset: D }) => {
  var T;
  const c = t.findIndex(({ props: n }) => n.id === r), d = t.findIndex(({ props: n }) => n.id === i), f = t[d], I = j(t, d, c), e = I[c - 1], g = I[c + 1], u = E(f), N = A(D), P = (((T = f == null ? void 0 : f.props) == null ? void 0 : T.level) ?? 0) + N, m = u !== !1 ? u : H(e, g), v = u !== !1 ? u : R(e, g);
  let o = P || a(g);
  P >= m ? o = m : P < v && (o = v);
  const w = () => {
    var l;
    return o === 0 || !e ? W : e.props.parentId && o === e.props.level ? e.props.parentId ?? null : e.props.level !== void 0 && o > e.props.level ? e.props.accepts ? e.props.id : e.props.parentId ?? e.props.id : ((l = I.slice(0, c).reverse().find((M) => M.props.level === o)) == null ? void 0 : l.props.parentId) ?? null;
  }, y = (n) => {
    var l;
    return n ? (l = t.find(({ props: M }) => M.id === n)) == null ? void 0 : l.props : null;
  }, h = w(), p = y(h), O = d < c && f.props.parentId !== h ? 1 : 0, x = I.filter(({ props: n }) => n.parentId === h);
  let s = x.findIndex(({ props: n }) => n.id === i);
  if (s < 0) {
    const n = x.findIndex(({ props: l }) => l.id === r);
    n >= 0 ? s = n : h === r ? s = -1 : N < 0 ? s = d < c ? x.length : -1 : d >= c && (s = x.length);
  }
  s = s + O;
  const C = (p == null ? void 0 : p.level) ?? 0;
  return {
    depth: o,
    maxDepth: m,
    minDepth: v,
    parentId: h ?? null,
    type: p == null ? void 0 : p.type,
    accepts: p == null ? void 0 : p.accepts,
    position: s >= 0 ? s : 0,
    isWithinParent: C ? o > C : !1,
    previousNode: e ? {
      id: e.props.id,
      depth: a(e),
      accepts: e.props.accepts
    } : null
  };
};
export {
  q as getProjection
};
//# sourceMappingURL=projection.es.js.map
