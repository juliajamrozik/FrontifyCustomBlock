import { arrayMove as v } from "@dnd-kit/sortable";
const h = ({
  eventName: r,
  activeId: m,
  activeTitle: s,
  overId: d,
  overTitle: p,
  treeState: i,
  currentPosition: a,
  setCurrentPosition: $
}) => {
  const n = i.projection;
  if (d && n) {
    if (r !== "onDragEnd") {
      if (a && n.parentId === a.parentId && d === a.overId)
        return;
      $({
        parentId: n.parentId,
        overId: d
      });
    }
    const c = i.nodes.map(({ props: e }) => ({
      id: e.id,
      level: e.level ?? 0,
      parentId: e.parentId
    })), I = c.findIndex(({ id: e }) => e === d), u = c.findIndex(({ id: e }) => e === m), f = v(c, u, I), t = f[I - 1];
    let o;
    const l = r === "onDragEnd" ? "dropped" : "moved", x = r === "onDragEnd" ? "dropped" : "nested";
    if (t)
      if (n.depth > t.level)
        o = `${s} was ${x} under ${p || t.id}.`;
      else {
        let e = t;
        for (; e && n.depth < e.level; ) {
          const g = e.parentId;
          e = f.find(({ id: b }) => b === g);
        }
        e && (o = `${s} was ${l} after ${p || e.id}.`);
      }
    else {
      const e = f[I + 1];
      o = `${s} was ${l} before ${p || e.id}.`;
    }
    return o;
  }
};
export {
  h as getMovementAnnouncement
};
//# sourceMappingURL=getMovementAnnouncements.es.js.map
