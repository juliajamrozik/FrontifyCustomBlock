import { KeyboardCode as n, closestCorners as L, getFirstCollision as O } from "@dnd-kit/core";
import { getProjection as b } from "../helpers/projection.es.js";
import { INDENTATION_WIDTH as g } from "../helpers/constants.es.js";
const B = [n.Down, n.Right, n.Up, n.Left], K = [n.Left, n.Right], F = (N) => (c, { currentCoordinates: a, context: { active: d, over: t, collisionRect: r, droppableRects: h, droppableContainers: u } }) => {
  if (B.includes(c.code)) {
    if (!d || !r)
      return;
    c.preventDefault();
    const {
      current: { nodes: f, offset: k }
    } = N;
    if (K.includes(c.code) && (t != null && t.id)) {
      const { depth: e, maxDepth: i, minDepth: s } = b({
        nodes: f,
        activeId: d.id,
        overId: t.id,
        dragOffset: k
      });
      switch (c.code) {
        case n.Left:
          if (e > s)
            return {
              ...a,
              x: a.x - g
            };
          break;
        case n.Right:
          if (e < i)
            return {
              ...a,
              x: a.x + g
            };
          break;
      }
      return;
    }
    const l = [];
    for (const [e, i] of u) {
      if (i != null && i.disabled || e === (t == null ? void 0 : t.id))
        continue;
      const s = h.get(e);
      if (s)
        switch (c.code) {
          case n.Down:
            r.top < s.top && l.push(i);
            break;
          case n.Up:
            r.top > s.top && l.push(i);
            break;
        }
    }
    const I = L({
      active: d,
      collisionRect: r,
      pointerCoordinates: null,
      droppableRects: h,
      droppableContainers: l
    });
    let o = O(I, "id");
    if (o === (t == null ? void 0 : t.id) && I.length > 1 && (o = I[1].id), o && (t != null && t.id)) {
      const e = h.get(d.id), i = h.get(o), s = u.get(o);
      if (e && i && s) {
        const w = f.findIndex(({ props: p }) => p.id === o), x = f[w], m = f.findIndex(({ props: p }) => p.id === d.id), D = f[m], C = (x.props.level - D.props.level) * g;
        if (x && D) {
          const { depth: p } = b({
            nodes: f,
            activeId: d.id,
            overId: o,
            dragOffset: C
          }), T = w > m ? 1 : -1, y = (r.height - e.height) / 2;
          return {
            x: i.left + p * g,
            y: i.top + T * y
          };
        }
      }
    }
  }
};
export {
  F as sortableTreeKeyboardCoordinates
};
//# sourceMappingURL=keyboardCoordinates.es.js.map
