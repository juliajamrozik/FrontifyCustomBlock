{"version":3,"file":"keyboardCoordinates.es.js","sources":["../../../../src/components/Tree/utils/keyboardCoordinates.ts"],"sourcesContent":["/* (c) Copyright Frontify Ltd., all rights reserved. */\n\nimport {\n    DroppableContainer,\n    KeyboardCode,\n    KeyboardCoordinateGetter,\n    closestCorners,\n    getFirstCollision,\n} from '@dnd-kit/core';\n\nimport { INDENTATION_WIDTH, getProjection } from '../helpers';\nimport type { SensorContext } from '../types';\n\nconst directions: string[] = [KeyboardCode.Down, KeyboardCode.Right, KeyboardCode.Up, KeyboardCode.Left];\n\nconst horizontal: string[] = [KeyboardCode.Left, KeyboardCode.Right];\n\nexport const sortableTreeKeyboardCoordinates: (context: SensorContext) => KeyboardCoordinateGetter =\n    (context) =>\n    (event, { currentCoordinates, context: { active, over, collisionRect, droppableRects, droppableContainers } }) => {\n        if (directions.includes(event.code)) {\n            if (!active || !collisionRect) {\n                return;\n            }\n\n            event.preventDefault();\n\n            const {\n                current: { nodes, offset },\n            } = context;\n\n            if (horizontal.includes(event.code) && over?.id) {\n                const { depth, maxDepth, minDepth } = getProjection({\n                    nodes,\n                    activeId: active.id as string,\n                    overId: over.id as string,\n                    dragOffset: offset,\n                });\n\n                switch (event.code) {\n                    case KeyboardCode.Left:\n                        if (depth > minDepth) {\n                            return {\n                                ...currentCoordinates,\n                                x: currentCoordinates.x - INDENTATION_WIDTH,\n                            };\n                        }\n                        break;\n                    case KeyboardCode.Right:\n                        if (depth < maxDepth) {\n                            return {\n                                ...currentCoordinates,\n                                x: currentCoordinates.x + INDENTATION_WIDTH,\n                            };\n                        }\n                        break;\n                }\n\n                return undefined;\n            }\n\n            const containers: DroppableContainer[] = [];\n\n            for (const [containerId, container] of droppableContainers) {\n                if (container?.disabled || containerId === over?.id) {\n                    continue;\n                }\n\n                const rect = droppableRects.get(containerId);\n\n                if (!rect) {\n                    continue;\n                }\n\n                switch (event.code) {\n                    case KeyboardCode.Down:\n                        if (collisionRect.top < rect.top) {\n                            containers.push(container);\n                        }\n                        break;\n                    case KeyboardCode.Up:\n                        if (collisionRect.top > rect.top) {\n                            containers.push(container);\n                        }\n                        break;\n                }\n            }\n\n            const collisions = closestCorners({\n                active,\n                collisionRect,\n                pointerCoordinates: null,\n                droppableRects,\n                droppableContainers: containers,\n            });\n\n            let closestId = getFirstCollision(collisions, 'id');\n\n            if (closestId === over?.id && collisions.length > 1) {\n                closestId = collisions[1].id;\n            }\n\n            if (closestId && over?.id) {\n                const activeRect = droppableRects.get(active.id);\n                const newRect = droppableRects.get(closestId);\n                const newDroppable = droppableContainers.get(closestId);\n\n                if (activeRect && newRect && newDroppable) {\n                    const newIndex = nodes.findIndex(({ props }) => props.id === closestId);\n                    const newNode = nodes[newIndex];\n                    const activeIndex = nodes.findIndex(({ props }) => props.id === active.id);\n                    const activeNode = nodes[activeIndex];\n\n                    const dragOffset = (newNode.props.level - activeNode.props.level) * INDENTATION_WIDTH;\n\n                    if (newNode && activeNode) {\n                        const { depth } = getProjection({\n                            nodes,\n                            activeId: active.id as string,\n                            overId: closestId as string,\n                            dragOffset,\n                        });\n\n                        const isBelow = newIndex > activeIndex;\n                        const modifier = isBelow ? 1 : -1;\n                        const offset = (collisionRect.height - activeRect.height) / 2;\n\n                        const newCoordinates = {\n                            x: newRect.left + depth * INDENTATION_WIDTH,\n                            y: newRect.top + modifier * offset,\n                        };\n\n                        return newCoordinates;\n                    }\n                }\n            }\n        }\n\n        return undefined;\n    };\n"],"names":["directions","KeyboardCode","horizontal","sortableTreeKeyboardCoordinates","context","event","currentCoordinates","active","over","collisionRect","droppableRects","droppableContainers","nodes","offset","depth","maxDepth","minDepth","getProjection","INDENTATION_WIDTH","containers","containerId","container","rect","collisions","closestCorners","closestId","getFirstCollision","activeRect","newRect","newDroppable","newIndex","props","newNode","activeIndex","activeNode","dragOffset","modifier"],"mappings":"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"}