import S, { memo as De, useMemo as L, useReducer as Se, useTransition as Te, useState as _, useEffect as M, useCallback as m, useRef as Ce, cloneElement as Re, isValidElement as z } from "react";
import { SortableContext as we, verticalListSortingStrategy as he } from "@dnd-kit/sortable";
import { restrictToWindowEdges as Oe } from "@dnd-kit/modifiers";
import { enableMapSet as _e, produce as xe } from "immer";
import { createPortal as be } from "react-dom";
import Q from "../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isEqual.es.js";
import { MeasuringStrategy as Le, KeyboardCode as T, useSensors as Me, useSensor as Z, PointerSensor as Ae, KeyboardSensor as Pe, DndContext as ke, closestCorners as ve, DragOverlay as Ge } from "@dnd-kit/core";
import { TreeContext as je } from "./TreeContext.es.js";
import { getReactNodeIdsInFlatArray as He, removeReactNodesFromFlatArray as Ke } from "./helpers/nodes.es.js";
import { findIndexById as Fe, getNodeChildrenIds as Ue, currentNodesChanged as Ve, getCurrentChildrenForNewNodesIfExpanded as ee, updateNodeWithNewChildren as Xe } from "./helpers/reducer.es.js";
import { sortableTreeKeyboardCoordinates as $e } from "./utils/keyboardCoordinates.es.js";
import { getMovementAnnouncement as G } from "./helpers/getMovementAnnouncements.es.js";
import { TreeItemOverlay as Be } from "./TreeItem/TreeItemOverlay.es.js";
import { recursivelyRemoveFragmentsAndEnrichChildren as Je } from "./utils/removeFragmentsAndEnrichChildren.es.js";
import { ROOT_ID as j } from "./helpers/constants.es.js";
import { useDeepCompareEffect as H } from "./utils/useDeepCompareEffect.es.js";
import { getProjection as We } from "./helpers/projection.es.js";
const Ye = {
  droppable: {
    strategy: Le.Always
  }
};
_e();
const qe = xe((o, d) => {
  switch (d.type) {
    case "EXPAND_NODE":
      o.expandedIds = new Set(o.expandedIds).add(d.payload);
      return;
    case "SHRINK_NODE":
      const C = new Set(o.expandedIds);
      C.delete(d.payload), o.expandedIds = C;
      return;
    case "SET_SELECTION_MODE":
      o.selectionMode = d.payload.selectionMode;
      return;
    case "SET_PROJECTION":
      Q(o.projection, d.payload) || (o.projection = d.payload);
      return;
    case "REGISTER_OVERLAY_ITEM":
      o.overlay = d.payload;
      return;
    case "REGISTER_ROOT_NODES":
      o.rootNodes = ee(
        o.rootNodes,
        o.expandedIds,
        d.payload
      );
      return;
    case "REGISTER_NODE_CHILDREN":
      const { id: p, children: c } = d.payload;
      if (Fe(o.rootNodes, p) === -1) {
        console.warn(`Parent element with ID "${p}" not found when registering children.`);
        return;
      }
      const y = Ue(o.rootNodes, p), I = c.map((N) => N.props.id);
      if (!Q(y, I) || Ve(y, o.rootNodes, c)) {
        const N = ee(
          o.rootNodes,
          o.expandedIds,
          c
        );
        o.rootNodes = Xe(o.rootNodes, p, N);
      }
      return;
    case "UNREGISTER_NODE_CHILDREN":
      const E = He(o.rootNodes, d.payload);
      E.length > 0 && (o.rootNodes = Ke(o.rootNodes, E));
      return;
    case "REGISTER_NODES":
      o.nodes = d.payload;
      return;
    case "REPLACE_EXPANDED":
      o.expandedIds = new Set(d.payload);
      return;
    case "REPLACE_SELECTED":
      o.selectedIds = new Set(d.payload);
      return;
    case "REPLACE_STATE":
      o.rootNodes = d.payload.rootNodes, o.overlay = d.payload.overlay, o.projection = d.payload.projection, o.selectedIds = d.payload.selectedIds, o.expandedIds = d.payload.expandedIds, o.selectionMode = d.payload.selectionMode;
      return;
    default:
      console.warn(`Updated tree with action "${d.type}" but it has not effect.`);
      return;
  }
}), ze = De(
  ({
    id: o,
    onDrop: d,
    onSelect: C = () => {
    },
    onExpand: p,
    onShrink: c,
    children: y,
    selectedIds: I,
    expandedIds: E,
    draggable: N = !1,
    multiselect: x = !1,
    "data-test-id": te = "fondue-tree"
  }) => {
    var J;
    const ne = L(
      () => ({
        selectionMode: "single",
        selectedIds: new Set(I ?? []),
        expandedIds: new Set(E ?? []),
        rootNodes: [],
        expandedNodes: [],
        nodes: [],
        nodesReady: !1,
        projection: null
      }),
      [E, I]
    ), [n, l] = Se(qe, ne), [, oe] = Te(), [R, K] = _(null), [A, P] = _(null), [k, F] = _(null), [b, w] = _(null);
    M(() => {
      const e = (t) => {
        x && (t.key === "Meta" || t.ctrlKey) && l({
          type: "SET_SELECTION_MODE",
          payload: { selectionMode: "multiselect" }
        });
      }, s = (t) => {
        x && (t.key === "Meta" || t.ctrlKey) && l({
          type: "SET_SELECTION_MODE",
          payload: { selectionMode: "single" }
        });
      };
      return x && (window.addEventListener("keydown", e), window.addEventListener("keyup", s)), () => {
        window.removeEventListener("keydown", e), window.removeEventListener("keyup", s);
      };
    }, [x]);
    const U = m((e) => {
      l({ type: "REGISTER_OVERLAY_ITEM", payload: e });
    }, []), V = m((e) => {
      l({ type: "REGISTER_NODE_CHILDREN", payload: e });
    }, []), X = m((e) => {
      l({ type: "UNREGISTER_NODE_CHILDREN", payload: e });
    }, []), f = m(
      (e) => {
        C(e);
      },
      [C]
    ), g = m(
      (e) => {
        if (p)
          return p(e);
        l({
          type: "EXPAND_NODE",
          payload: e
        });
      },
      [p]
    ), D = m(
      (e) => {
        if (c)
          return c(e);
        l({
          type: "SHRINK_NODE",
          payload: e
        });
      },
      [c]
    ), re = (e) => {
      var i, h;
      $();
      const { over: s, active: t } = e;
      if (!(s != null && s.id) || !(t != null && t.id) || !((i = n.projection) != null && i.parentId))
        return;
      const r = n.nodes.find((O) => O.props.id === t.id), a = (h = r == null ? void 0 : r.props) == null ? void 0 : h.contentComponent;
      d == null || d({
        id: t.id.toString(),
        parentId: n.projection.parentId,
        sort: n.projection.position,
        contentComponent: a
      });
    }, se = ({ active: { id: e, data: s } }) => {
      F(e), P(e), e && s.current && w({
        parentId: s.current.parentId,
        overId: e
      }), document.body.style.setProperty("cursor", "grabbing");
    }, de = ({ over: e }) => {
      P((e == null ? void 0 : e.id) ?? null);
    }, ae = ({ delta: e }) => {
      K(e.x);
    }, le = () => {
      $();
    }, $ = () => {
      P(null), F(null), K(0), w(null), document.body.style.setProperty("cursor", "default");
    }, ie = m(
      (e) => {
        const s = document.activeElement;
        if (!(s != null && s.parentElement) || s.getAttribute("role") !== "treeitem" || !(s instanceof HTMLLIElement))
          return;
        const t = Array.from(s.parentElement.children).filter(
          (u) => u.nodeName === "LI"
        ), r = t.indexOf(s), a = n.nodes[r], i = a.props.id, h = n.expandedIds.has(i), O = a.props.parentId, v = s.getAttribute("data-has-children") === "true", { code: Ie } = e, W = () => {
          e.preventDefault(), f(i);
        }, Y = () => {
          e.preventDefault(), g(i);
        }, Ne = () => {
          e.preventDefault(), D(i);
        }, fe = () => {
          const u = (r + t.length - 1) % t.length;
          t[u].focus();
        }, q = () => {
          const u = (r + 1) % t.length;
          t[u].focus();
        };
        switch (Ie) {
          case T.Enter:
            W();
            break;
          case T.Space:
            v ? Y() : W();
            break;
          case T.Right:
            if (!v)
              break;
            h ? q() : Y();
            break;
          case T.Left:
            if (v && h)
              Ne();
            else if (O && O !== j) {
              const u = n.nodes.findIndex((ge) => ge.props.id === O);
              t[u].focus();
            }
            break;
          case T.Up:
            e.preventDefault(), fe();
            break;
          case T.Down:
            e.preventDefault(), q();
            break;
        }
      },
      [g, D, f, n.expandedIds, n.nodes]
    ), B = Ce({
      nodes: n.nodes,
      offset: R ?? 0
    }), [pe] = _(() => $e(B)), ce = Me(Z(Ae), Z(Pe, { coordinateGetter: pe })), Ee = L(() => {
      const e = (t) => {
        let r = t.id;
        const a = n.nodes.find((i) => i.props.id === t.id);
        return a && z(a.props.contentComponent) ? r = a.props.contentComponent.props.title : a && a.props.label && (r = a.props.label), r;
      }, s = (t) => {
        let r = t == null ? void 0 : t.id;
        const a = n.nodes.find((i) => i.props.id === (t == null ? void 0 : t.id));
        return a && z(a.props.contentComponent) ? r = a.props.contentComponent.props.title : a && a.props.label && (r = a.props.label), r;
      };
      return {
        onDragStart({ active: t }) {
          return `Picked up ${e(t) || t.id}.`;
        },
        onDragMove({ active: t, over: r }) {
          return G({
            eventName: "onDragMove",
            activeId: t.id,
            activeTitle: e(t),
            overId: r == null ? void 0 : r.id,
            overTitle: s(r),
            treeState: n,
            setCurrentPosition: w,
            currentPosition: b
          });
        },
        onDragOver({ active: t, over: r }) {
          return G({
            eventName: "onDragOver",
            activeId: t.id,
            activeTitle: e(t),
            overId: r == null ? void 0 : r.id,
            overTitle: s(r),
            treeState: n,
            setCurrentPosition: w,
            currentPosition: b
          });
        },
        onDragEnd({ active: t, over: r }) {
          return G({
            eventName: "onDragEnd",
            activeId: t.id,
            activeTitle: e(t),
            overId: r == null ? void 0 : r.id,
            overTitle: s(r),
            treeState: n,
            setCurrentPosition: w,
            currentPosition: b
          });
        },
        onDragCancel({ active: t }) {
          return `Moving was cancelled. ${e(t)} was dropped in its original position.`;
        }
      };
    }, [b, n]);
    H(() => {
      y && l({
        type: "REGISTER_ROOT_NODES",
        payload: Je(y, { parentId: j, level: 0 })
      });
    }, [y]), H(() => {
      n.rootNodes.length !== 0 && oe(() => {
        const e = [];
        for (const s of n.rootNodes) {
          const t = s.props.parentId;
          typeof t == "string" && (t === j || n.expandedIds.has(t) && e.find((r) => r.id === t)) && e.push({ id: s.props.id, node: s });
        }
        l({
          type: "REGISTER_NODES",
          payload: e.map((s) => s.node)
        });
      });
    }, [n.rootNodes, n.expandedIds]), M(() => {
      l({
        type: "REPLACE_EXPANDED",
        payload: E ?? []
      });
    }, [E]), M(() => {
      l({
        type: "REPLACE_SELECTED",
        payload: I ?? []
      });
    }, [I]), H(() => {
      B.current = {
        nodes: n.nodes,
        offset: R ?? 0
      };
    }, [R, n.nodes]), M(() => {
      const e = k && A ? We({
        nodes: n.nodes,
        activeId: k,
        overId: A,
        dragOffset: R ?? 0
      }) : null;
      l({
        type: "SET_PROJECTION",
        payload: e
      });
    }, [k, R, A, n.nodes]);
    const { nodes: ue, items: me } = L(() => ({
      items: n.nodes.map((e) => e.props.id),
      nodes: n.nodes.map(
        (e) => Re(e, {
          treeDraggable: N,
          registerOverlay: U,
          onExpand: g,
          onShrink: D,
          onSelect: f,
          registerNodeChildren: V,
          unregisterNodeChildren: X
        })
      )
    }), [
      N,
      g,
      D,
      f,
      U,
      n.nodes,
      V,
      X
    ]), ye = L(
      () => ({
        treeState: n,
        onSelect: f,
        onExpand: g,
        onShrink: D
      }),
      [n, f, g, D]
    );
    return /* @__PURE__ */ S.createElement(je.Provider, { value: ye }, /* @__PURE__ */ S.createElement(
      "ul",
      {
        id: o,
        role: "tree",
        "data-test-id": te,
        onKeyDown: ie,
        "aria-multiselectable": n.selectionMode === "multiselect",
        className: "tw-p-0 tw-m-0 tw-font-sans tw-font-normal tw-list-none tw-text-left tw-text-sm tw-select-none"
      },
      /* @__PURE__ */ S.createElement(
        ke,
        {
          sensors: ce,
          measuring: Ye,
          onDragEnd: re,
          onDragOver: de,
          onDragMove: ae,
          onDragStart: se,
          onDragCancel: le,
          accessibility: {
            announcements: Ee,
            container: ((J = document.getElementById(o)) == null ? void 0 : J.parentElement) ?? document.body
          },
          collisionDetection: ve
        },
        /* @__PURE__ */ S.createElement(we, { items: me, strategy: he }, ue),
        be(
          /* @__PURE__ */ S.createElement(Ge, { wrapperElement: "ul", dropAnimation: null, modifiers: [Oe] }, n.overlay && /* @__PURE__ */ S.createElement(
            Be,
            {
              ...n.overlay,
              isSelected: n.selectedIds.has(n.overlay.id)
            }
          )),
          document.body
        )
      )
    ));
  }
);
ze.displayName = "FondueTree";
export {
  ze as Tree
};
//# sourceMappingURL=Tree.es.js.map
