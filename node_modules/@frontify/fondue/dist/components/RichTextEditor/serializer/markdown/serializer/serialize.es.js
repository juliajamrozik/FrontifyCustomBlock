import { applyFormattingToLeafNode as L } from "./applyFormattingToLeafNode.es.js";
import { isLeafNode as s } from "./isLeafNode.es.js";
import { applyFormattingToBlockNode as T } from "./applyFormattingToBlockNode.es.js";
import { getSelectedOptions as N, BREAK_TAG as l } from "../utils.es.js";
const c = ["thematicBreak", "image", "mention"], A = (e, t) => s(e) ? !1 : t.includes(e.type || ""), E = (e, t) => !s(e) && Array.isArray(e.children) ? e.children.some(
  (i) => !s(i) && (i.type === t.link || i.type === t.image)
) : !1, D = (e, t) => e === t.mention, P = (e, t, i, r) => !e && t === `
` && i.parentType === r.paragraph && !D(i.type, r), w = (e, t, i) => e.includes(t.type || "") ? i + 1 : i, d = (e, t) => {
  const i = t.nodeTypes, r = e.text ?? "";
  let o = e.type ?? void 0;
  const y = e.parentType ?? void 0, p = [i.ulList, i.olList];
  let a = r;
  if (s(e) || (a = e.children.map((n) => {
    const m = A(n, p), f = p.includes(e.type ?? ""), g = E(e, i);
    return d(
      { ...n, parentType: o },
      {
        nodeTypes: i,
        // WOAH.
        // what we're doing here is pretty tricky, it relates to the block below where
        // we check for ignoreParagraphNewline and set type to paragraph.
        // We want to strip out empty paragraphs sometimes, but other times we don't.
        // If we're the descendant of a list, we know we don't want a bunch
        // of whitespace. If we're parallel to a link we also don't want
        // to respect neighboring paragraphs
        ignoreParagraphNewline: (t.ignoreParagraphNewline || m || f || g) && // if we have c.break, never ignore empty paragraph new line
        !n.break,
        // track depth of nested lists so we can add proper spacing
        listDepth: w(p, n, t.listDepth),
        linkDestinationKey: t.linkDestinationKey
      }
    );
  }).join("")), P(t.ignoreParagraphNewline, r, e, i) && (o = i.paragraph, a = l), !(a === "" && !c.find((n) => i[n] === o)))
    return a !== l && s(e) ? L(a, e) : T(t, a, e, t.listDepth, o, y);
};
function K(e) {
  const t = N(e);
  return (i) => i.map((r) => d(r, t)).join("");
}
export {
  K as default
};
//# sourceMappingURL=serialize.es.js.map
