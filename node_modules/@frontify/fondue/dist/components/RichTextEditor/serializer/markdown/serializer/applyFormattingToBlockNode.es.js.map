{"version":3,"file":"applyFormattingToBlockNode.es.js","sources":["../../../../../../src/components/RichTextEditor/serializer/markdown/serializer/applyFormattingToBlockNode.ts"],"sourcesContent":["/* (c) Copyright Frontify Ltd., all rights reserved. */\n\nimport escapeHtml from 'escape-html';\nimport { BlockType, InputNodeTypes, NodeType, OptionType, Targets } from '../types';\nimport { isLeafNode } from './isLeafNode';\nimport { isMaliciousLink } from '../utils';\n\nconst processMentionNode = (chunk: BlockType) => `@[${chunk.category}:${chunk.id}]`;\n\nconst processListItemChildNode = (children: string) => `${children}\\n`;\n\nconst processListItemNode = (\n    nodeTypes: InputNodeTypes,\n    children: string,\n    chunk: NodeType,\n    listDepth: number,\n): string => {\n    const isOL = chunk && chunk.parentType === nodeTypes.olList;\n    const treatAsLeaf = (chunk as BlockType).children.length === 1 && isLeafNode((chunk as BlockType).children[0]);\n\n    let spacer = '';\n    for (let k = 0; listDepth > k; k++) {\n        if (isOL) {\n            // https://github.com/remarkjs/remark-react/issues/65\n            spacer += '   ';\n        } else {\n            spacer += '  ';\n        }\n    }\n    return `${spacer}${isOL ? '1.' : '-'} ${children}${treatAsLeaf ? '\\n' : ''}`;\n};\n\nconst shouldEscapeNode = (children: string, nodeTypes: InputNodeTypes, type?: string, parentType?: string) => {\n    // don't escape if: code block, image, img\n    const isCodeBlock = parentType === nodeTypes.codeBlock || type === nodeTypes.codeBlock;\n    if (!isCodeBlock) {\n        children = escapeHtml(children);\n    }\n\n    return children;\n};\n\nexport const applyFormattingToBlockNode = (\n    options: OptionType,\n    children: string,\n    chunk: NodeType,\n    listDepth: number,\n    type?: string,\n    parentType?: string,\n) => {\n    const nodeTypes = options.nodeTypes as InputNodeTypes;\n\n    switch (type) {\n        case nodeTypes.heading[1]:\n            return `# ${children}\\n`;\n        case nodeTypes.heading[2]:\n            return `## ${children}\\n`;\n        case nodeTypes.heading[3]:\n            return `### ${children}\\n`;\n        case nodeTypes.heading[4]:\n            return `#### ${children}\\n`;\n        case nodeTypes.heading[5]:\n            return `##### ${children}\\n`;\n        case nodeTypes.heading[6]:\n            return `###### ${children}\\n`;\n\n        case nodeTypes.blockQuote:\n            /**\n             * For some reason, marked is parsing blockquote w/ one new line as\n             * continued blockquote, so adding two new lines ensures that doesn't\n             * happen\n             */\n            return `> ${children}`;\n\n        case nodeTypes.codeBlock:\n            return `\\`\\`\\`${(chunk as BlockType).language || ''}\\n${children}\\n\\`\\`\\`\\n`;\n\n        case nodeTypes.link:\n            let linkUrl = (chunk as BlockType).url ?? '';\n            linkUrl = isMaliciousLink(linkUrl) ? '' : linkUrl;\n            const target = (chunk as BlockType).target ?? Targets.Blank;\n            return `[${children}](${linkUrl}){:target=\"${target}\"}`;\n\n        case nodeTypes.image:\n            let imageUrl = (chunk as BlockType).link ?? '';\n            imageUrl = isMaliciousLink(imageUrl) ? '' : imageUrl;\n            return `![${(chunk as BlockType).caption}](${imageUrl})`;\n\n        case nodeTypes.ulList:\n        case nodeTypes.olList:\n            return `\\n${children}\\n`;\n\n        case nodeTypes.listItem:\n            return processListItemNode(nodeTypes, children, chunk, listDepth);\n\n        case nodeTypes.listItemChild:\n            return processListItemChildNode(children);\n\n        case nodeTypes.paragraph:\n            return `${children}\\n\\n`;\n\n        case nodeTypes.thematicBreak:\n            return `\\n---${children}\\n\\n`;\n\n        case nodeTypes.mention:\n            return processMentionNode(chunk as BlockType);\n\n        default:\n            return shouldEscapeNode(children, nodeTypes, type, parentType);\n    }\n};\n"],"names":["processMentionNode","chunk","processListItemChildNode","children","processListItemNode","nodeTypes","listDepth","isOL","treatAsLeaf","isLeafNode","spacer","k","shouldEscapeNode","type","parentType","escapeHtml","applyFormattingToBlockNode","options","linkUrl","isMaliciousLink","target","Targets","imageUrl"],"mappings":";;;;AAOA,MAAMA,IAAqB,CAACC,MAAqB,KAAKA,EAAM,YAAYA,EAAM,OAExEC,IAA2B,CAACC,MAAqB,GAAGA;AAAA,GAEpDC,IAAsB,CACxBC,GACAF,GACAF,GACAK,MACS;AACT,QAAMC,IAAON,KAASA,EAAM,eAAeI,EAAU,QAC/CG,IAAeP,EAAoB,SAAS,WAAW,KAAKQ,EAAYR,EAAoB,SAAS,CAAC,CAAC;AAE7G,MAAIS,IAAS;AACb,WAASC,IAAI,GAAGL,IAAYK,GAAGA;AAC3B,IAAIJ,IAEUG,KAAA,QAEAA,KAAA;AAGlB,SAAO,GAAGA,IAASH,IAAO,OAAO,OAAOJ,IAAWK,IAAc;AAAA,IAAO;AAC5E,GAEMI,IAAmB,CAACT,GAAkBE,GAA2BQ,GAAeC,OAE9DA,MAAeT,EAAU,aAAaQ,MAASR,EAAU,cAEzEF,IAAWY,EAAWZ,CAAQ,IAG3BA,IAGEa,IAA6B,CACtCC,GACAd,GACAF,GACAK,GACAO,GACAC,MACC;AACD,QAAMT,IAAYY,EAAQ;AAE1B,UAAQJ,GAAM;AAAA,IACV,KAAKR,EAAU,QAAQ,CAAC;AACpB,aAAO,KAAKF;AAAA;AAAA,IAChB,KAAKE,EAAU,QAAQ,CAAC;AACpB,aAAO,MAAMF;AAAA;AAAA,IACjB,KAAKE,EAAU,QAAQ,CAAC;AACpB,aAAO,OAAOF;AAAA;AAAA,IAClB,KAAKE,EAAU,QAAQ,CAAC;AACpB,aAAO,QAAQF;AAAA;AAAA,IACnB,KAAKE,EAAU,QAAQ,CAAC;AACpB,aAAO,SAASF;AAAA;AAAA,IACpB,KAAKE,EAAU,QAAQ,CAAC;AACpB,aAAO,UAAUF;AAAA;AAAA,IAErB,KAAKE,EAAU;AAMX,aAAO,KAAKF;AAAA,IAEhB,KAAKE,EAAU;AACJ,aAAA,SAAUJ,EAAoB,YAAY;AAAA,EAAOE;AAAA;AAAA;AAAA,IAE5D,KAAKE,EAAU;AACP,UAAAa,IAAWjB,EAAoB,OAAO;AAChC,MAAAiB,IAAAC,EAAgBD,CAAO,IAAI,KAAKA;AACpC,YAAAE,IAAUnB,EAAoB,UAAUoB,EAAQ;AAC/C,aAAA,IAAIlB,MAAae,eAAqBE;AAAA,IAEjD,KAAKf,EAAU;AACP,UAAAiB,IAAYrB,EAAoB,QAAQ;AACjC,aAAAqB,IAAAH,EAAgBG,CAAQ,IAAI,KAAKA,GACrC,KAAMrB,EAAoB,YAAYqB;AAAA,IAEjD,KAAKjB,EAAU;AAAA,IACf,KAAKA,EAAU;AACJ,aAAA;AAAA,EAAKF;AAAA;AAAA,IAEhB,KAAKE,EAAU;AACX,aAAOD,EAAoBC,GAAWF,GAAUF,GAAOK,CAAS;AAAA,IAEpE,KAAKD,EAAU;AACX,aAAOH,EAAyBC,CAAQ;AAAA,IAE5C,KAAKE,EAAU;AACX,aAAO,GAAGF;AAAA;AAAA;AAAA,IAEd,KAAKE,EAAU;AACJ,aAAA;AAAA,KAAQF;AAAA;AAAA;AAAA,IAEnB,KAAKE,EAAU;AACX,aAAOL,EAAmBC,CAAkB;AAAA,IAEhD;AACI,aAAOW,EAAiBT,GAAUE,GAAWQ,GAAMC,CAAU;AAAA,EACrE;AACJ;"}