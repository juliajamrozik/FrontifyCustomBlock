{"version":3,"file":"deserialize.es.js","sources":["../../../../../../src/components/RichTextEditor/serializer/markdown/deserializer/deserialize.ts"],"sourcesContent":["/* (c) Copyright Frontify Ltd., all rights reserved. */\n\nimport {\n    BlockQuoteNode,\n    CodeBlockNode,\n    DeserializedNode,\n    HeadingNode,\n    ImageNode,\n    InputNodeTypes,\n    ItalicNode,\n    LinkNode,\n    ListItemChildNode,\n    ListItemNode,\n    ListNode,\n    MarkdownAstNode,\n    OptionType,\n    ParagraphNode,\n    TextNode,\n    ThematicBreakNode,\n} from '../types';\nimport { MENTION_DESERIALIZE_REGEX, isMaliciousLink } from '../utils';\nimport { DeserializerConfig } from './types';\n\nexport default function deserialize<T extends InputNodeTypes>(\n    node: MarkdownAstNode,\n    options: OptionType,\n    config?: DeserializerConfig,\n) {\n    const types = options?.nodeTypes as InputNodeTypes;\n    const { linkDestinationKey, imageSourceKey, imageCaptionKey } = getOptions(options);\n\n    let children: Array<DeserializedNode<T>> = [{ text: '' }];\n\n    if (hasNodeChildren(node.children)) {\n        children = node.children.flatMap((c: MarkdownAstNode) =>\n            deserialize(\n                {\n                    ...c,\n                    ordered: node.ordered || false,\n                },\n                options,\n                config,\n            ),\n        );\n    }\n\n    switch (node.type) {\n        case 'mention':\n            const value = node.children ? node.children[0].value : undefined;\n            const matches = value?.match(MENTION_DESERIALIZE_REGEX) as RegExpMatchArray;\n            return {\n                type: types.mention,\n                category: matches[1],\n                id: matches[2],\n                children: [{ text: '' }],\n            };\n        case 'heading':\n            return {\n                type: types.heading[node.depth || 1],\n                children,\n            } as HeadingNode<T>;\n        case 'list':\n            return {\n                type: node.ordered ? types.olList : types.ulList,\n                children,\n            } as ListNode<T>;\n        case 'listItem':\n            return { type: types.listItem, children } as ListItemNode<T>;\n        case 'listItemChild':\n            return { type: types.listItemChild, children } as ListItemChildNode<T>;\n        case 'paragraph':\n            return { type: types.paragraph, children } as ParagraphNode<T>;\n        case 'link':\n            return {\n                type: types.link,\n                [linkDestinationKey]: allowUnsafeLink(node.url, config?.allowUnsafeLink),\n                target: node.target,\n                children,\n            } as LinkNode<T>;\n        case 'image':\n            return {\n                type: types.image,\n                children: [{ text: '' }],\n                [imageSourceKey]: allowUnsafeLink(node.url, config?.allowUnsafeLink),\n                [imageCaptionKey]: node.alt,\n            } as ImageNode<T>;\n        case 'blockquote':\n            return { type: types.blockQuote, children } as BlockQuoteNode<T>;\n        case 'code':\n            return {\n                type: types.codeBlock,\n                language: node.lang ?? undefined,\n                children: [{ text: node.value }],\n            } as CodeBlockNode<T>;\n\n        case 'html':\n            if (node.value?.includes('<br>')) {\n                return {\n                    break: true,\n                    type: types.paragraph,\n                    children: [{ text: node.value?.replace(/<br>/g, '') || '' }],\n                } as ParagraphNode<T>;\n            }\n            return { type: types.paragraph, children: [{ text: node.value || '' }] };\n\n        case 'emphasis':\n            return {\n                [types.emphasisMark as string]: true,\n                ...forceLeafNode(children as Array<TextNode>),\n                ...persistLeafFormats(children as Array<MarkdownAstNode>),\n            } as unknown as ItalicNode<T>;\n        case 'strong':\n            return {\n                [types.strongMark as string]: true,\n                ...forceLeafNode(children as Array<TextNode>),\n                ...persistLeafFormats(children as Array<MarkdownAstNode>),\n            };\n        case 'delete':\n            return {\n                [types.deleteMark as string]: true,\n                ...forceLeafNode(children as Array<TextNode>),\n                ...persistLeafFormats(children as Array<MarkdownAstNode>),\n            };\n        case 'inlineCode':\n            return {\n                [types.inlineCodeMark as string]: true,\n                text: node.value,\n                ...persistLeafFormats(children as Array<MarkdownAstNode>),\n            };\n        case 'thematicBreak':\n            return {\n                type: types.thematicBreak,\n                children: [{ text: '' }],\n            } as ThematicBreakNode<T>;\n\n        case 'text':\n        default:\n            return { text: node.value ?? '' };\n    }\n}\n\nconst hasNodeChildren = (children: MarkdownAstNode['children']): children is MarkdownAstNode[] =>\n    !!children && Array.isArray(children) && children.length > 0;\n\nconst forceLeafNode = (children: Array<TextNode>) => ({\n    text: children.map((k) => k?.text).join(''),\n});\n\n// This function is will take any unknown keys, and bring them up a level\n// allowing leaf nodes to have many different formats at once\n// for example, bold and italic on the same node\nconst persistLeafFormats = (children: Array<MarkdownAstNode>): Omit<MarkdownAstNode, 'children' | 'type' | 'text'> => {\n    return children.reduce((acc, node) => {\n        for (const key of Object.keys(node) as Array<keyof MarkdownAstNode>) {\n            if (key === 'children' || key === 'type' || key === 'text') {\n                continue;\n            }\n\n            acc[key] = node[key];\n        }\n\n        return acc;\n    }, {});\n};\n\nconst getOptions = (options: OptionType) => {\n    const linkDestinationKey = options.linkDestinationKey ?? 'link';\n    const imageSourceKey = options.imageSourceKey ?? 'link';\n    const imageCaptionKey = options.imageCaptionKey ?? 'caption';\n\n    return { linkDestinationKey, imageSourceKey, imageCaptionKey };\n};\n\nconst allowUnsafeLink = (link?: string, allow = false): string | undefined =>\n    !allow && link && !isMaliciousLink(link) ? link : undefined;\n"],"names":["deserialize","node","options","config","types","linkDestinationKey","imageSourceKey","imageCaptionKey","getOptions","children","hasNodeChildren","c","value","matches","MENTION_DESERIALIZE_REGEX","allowUnsafeLink","_a","_b","forceLeafNode","persistLeafFormats","k","acc","key","link","allow","isMaliciousLink"],"mappings":";AAuBwB,SAAAA,EACpBC,GACAC,GACAC,GACF;;AACE,QAAMC,IAAQF,KAAA,gBAAAA,EAAS,WACjB,EAAE,oBAAAG,GAAoB,gBAAAC,GAAgB,iBAAAC,EAAgB,IAAIC,EAAWN,CAAO;AAElF,MAAIO,IAAuC,CAAC,EAAE,MAAM,GAAI,CAAA;AAexD,UAbIC,EAAgBT,EAAK,QAAQ,MAC7BQ,IAAWR,EAAK,SAAS;AAAA,IAAQ,CAACU,MAC9BX;AAAA,MACI;AAAA,QACI,GAAGW;AAAA,QACH,SAASV,EAAK,WAAW;AAAA,MAC7B;AAAA,MACAC;AAAA,MACAC;AAAA,IACJ;AAAA,EAAA,IAIAF,EAAK,MAAM;AAAA,IACf,KAAK;AACD,YAAMW,IAAQX,EAAK,WAAWA,EAAK,SAAS,CAAC,EAAE,QAAQ,QACjDY,IAAUD,KAAA,gBAAAA,EAAO,MAAME;AACtB,aAAA;AAAA,QACH,MAAMV,EAAM;AAAA,QACZ,UAAUS,EAAQ,CAAC;AAAA,QACnB,IAAIA,EAAQ,CAAC;AAAA,QACb,UAAU,CAAC,EAAE,MAAM,IAAI;AAAA,MAAA;AAAA,IAE/B,KAAK;AACM,aAAA;AAAA,QACH,MAAMT,EAAM,QAAQH,EAAK,SAAS,CAAC;AAAA,QACnC,UAAAQ;AAAA,MAAA;AAAA,IAER,KAAK;AACM,aAAA;AAAA,QACH,MAAMR,EAAK,UAAUG,EAAM,SAASA,EAAM;AAAA,QAC1C,UAAAK;AAAA,MAAA;AAAA,IAER,KAAK;AACD,aAAO,EAAE,MAAML,EAAM,UAAU,UAAAK,EAAS;AAAA,IAC5C,KAAK;AACD,aAAO,EAAE,MAAML,EAAM,eAAe,UAAAK,EAAS;AAAA,IACjD,KAAK;AACD,aAAO,EAAE,MAAML,EAAM,WAAW,UAAAK,EAAS;AAAA,IAC7C,KAAK;AACM,aAAA;AAAA,QACH,MAAML,EAAM;AAAA,QACZ,CAACC,CAAkB,GAAGU,EAAgBd,EAAK,KAAKE,KAAA,gBAAAA,EAAQ,eAAe;AAAA,QACvE,QAAQF,EAAK;AAAA,QACb,UAAAQ;AAAA,MAAA;AAAA,IAER,KAAK;AACM,aAAA;AAAA,QACH,MAAML,EAAM;AAAA,QACZ,UAAU,CAAC,EAAE,MAAM,IAAI;AAAA,QACvB,CAACE,CAAc,GAAGS,EAAgBd,EAAK,KAAKE,KAAA,gBAAAA,EAAQ,eAAe;AAAA,QACnE,CAACI,CAAe,GAAGN,EAAK;AAAA,MAAA;AAAA,IAEhC,KAAK;AACD,aAAO,EAAE,MAAMG,EAAM,YAAY,UAAAK,EAAS;AAAA,IAC9C,KAAK;AACM,aAAA;AAAA,QACH,MAAML,EAAM;AAAA,QACZ,UAAUH,EAAK,QAAQ;AAAA,QACvB,UAAU,CAAC,EAAE,MAAMA,EAAK,OAAO;AAAA,MAAA;AAAA,IAGvC,KAAK;AACD,cAAIe,IAAAf,EAAK,UAAL,QAAAe,EAAY,SAAS,UACd;AAAA,QACH,OAAO;AAAA,QACP,MAAMZ,EAAM;AAAA,QACZ,UAAU,CAAC,EAAE,QAAMa,IAAAhB,EAAK,UAAL,gBAAAgB,EAAY,QAAQ,SAAS,QAAO,IAAI;AAAA,MAAA,IAG5D,EAAE,MAAMb,EAAM,WAAW,UAAU,CAAC,EAAE,MAAMH,EAAK,SAAS,GAAG,CAAC,EAAE;AAAA,IAE3E,KAAK;AACM,aAAA;AAAA,QACH,CAACG,EAAM,YAAsB,GAAG;AAAA,QAChC,GAAGc,EAAcT,CAA2B;AAAA,QAC5C,GAAGU,EAAmBV,CAAkC;AAAA,MAAA;AAAA,IAEhE,KAAK;AACM,aAAA;AAAA,QACH,CAACL,EAAM,UAAoB,GAAG;AAAA,QAC9B,GAAGc,EAAcT,CAA2B;AAAA,QAC5C,GAAGU,EAAmBV,CAAkC;AAAA,MAAA;AAAA,IAEhE,KAAK;AACM,aAAA;AAAA,QACH,CAACL,EAAM,UAAoB,GAAG;AAAA,QAC9B,GAAGc,EAAcT,CAA2B;AAAA,QAC5C,GAAGU,EAAmBV,CAAkC;AAAA,MAAA;AAAA,IAEhE,KAAK;AACM,aAAA;AAAA,QACH,CAACL,EAAM,cAAwB,GAAG;AAAA,QAClC,MAAMH,EAAK;AAAA,QACX,GAAGkB,EAAmBV,CAAkC;AAAA,MAAA;AAAA,IAEhE,KAAK;AACM,aAAA;AAAA,QACH,MAAML,EAAM;AAAA,QACZ,UAAU,CAAC,EAAE,MAAM,IAAI;AAAA,MAAA;AAAA,IAG/B,KAAK;AAAA,IACL;AACI,aAAO,EAAE,MAAMH,EAAK,SAAS,GAAG;AAAA,EACxC;AACJ;AAEA,MAAMS,IAAkB,CAACD,MACrB,CAAC,CAACA,KAAY,MAAM,QAAQA,CAAQ,KAAKA,EAAS,SAAS,GAEzDS,IAAgB,CAACT,OAA+B;AAAA,EAClD,MAAMA,EAAS,IAAI,CAACW,MAAMA,KAAA,gBAAAA,EAAG,IAAI,EAAE,KAAK,EAAE;AAC9C,IAKMD,IAAqB,CAACV,MACjBA,EAAS,OAAO,CAACY,GAAKpB,MAAS;AAClC,aAAWqB,KAAO,OAAO,KAAKrB,CAAI;AAC9B,IAAIqB,MAAQ,cAAcA,MAAQ,UAAUA,MAAQ,WAIhDD,EAAAC,CAAG,IAAIrB,EAAKqB,CAAG;AAGhB,SAAAD;AACX,GAAG,CAAE,CAAA,GAGHb,IAAa,CAACN,MAAwB;AAClC,QAAAG,IAAqBH,EAAQ,sBAAsB,QACnDI,IAAiBJ,EAAQ,kBAAkB,QAC3CK,IAAkBL,EAAQ,mBAAmB;AAE5C,SAAA,EAAE,oBAAAG,GAAoB,gBAAAC,GAAgB,iBAAAC;AACjD,GAEMQ,IAAkB,CAACQ,GAAeC,IAAQ,OAC5C,CAACA,KAASD,KAAQ,CAACE,EAAgBF,CAAI,IAAIA,IAAO;"}