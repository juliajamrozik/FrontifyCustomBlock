{"version":3,"file":"serialize.es.js","sources":["../../../../../../src/components/RichTextEditor/serializer/markdown/serializer/serialize.ts"],"sourcesContent":["/* (c) Copyright Frontify Ltd., all rights reserved. */\n\nimport { BlockType, InputNodeTypes, LeafType, NodeType, OptionType, PartialOptionType } from '../types';\nimport { applyFormattingToLeafNode } from './applyFormattingToLeafNode';\nimport { isLeafNode } from './isLeafNode';\nimport { applyFormattingToBlockNode } from './applyFormattingToBlockNode';\nimport { BREAK_TAG, getSelectedOptions } from '../utils';\n\nconst IGNORE_ELEMENTS: Array<keyof InputNodeTypes> = ['thematicBreak', 'image', 'mention'];\n\nconst isChildAList = (chunk: NodeType, LIST_TYPES: string[]) =>\n    !isLeafNode(chunk) ? LIST_TYPES.includes(chunk.type || '') : false;\n\nconst doesChildHasALink = (chunk: NodeType, nodeTypes: InputNodeTypes) =>\n    !isLeafNode(chunk) && Array.isArray(chunk.children)\n        ? chunk.children.some(\n              (child) => !isLeafNode(child) && (child.type === nodeTypes.link || child.type === nodeTypes.image),\n          )\n        : false;\n\nconst isMentionType = (type: string, nodeTypes: InputNodeTypes) => type === nodeTypes.mention;\n\nconst shouldIgnoreParagraphNewline = (\n    ignoreParagraphNewline: boolean,\n    text: string,\n    chunk: NodeType,\n    nodeTypes: InputNodeTypes,\n) =>\n    !ignoreParagraphNewline &&\n    text === '\\n' &&\n    chunk.parentType === nodeTypes.paragraph &&\n    !isMentionType((chunk as BlockType).type, nodeTypes);\n\nconst getDepthOfNestedLists = (listTypes: string[], children: NodeType, listDepth: number) =>\n    listTypes.includes((children as BlockType).type || '') ? listDepth + 1 : listDepth;\n\nconst process = (chunk: NodeType, options: OptionType) => {\n    const nodeTypes = options.nodeTypes as InputNodeTypes;\n    const text = (chunk as LeafType).text ?? '';\n    let type = (chunk as BlockType).type ?? undefined;\n    const parentType = (chunk as BlockType).parentType ?? undefined;\n    const LIST_TYPES = [nodeTypes.ulList, nodeTypes.olList];\n    let children = text;\n\n    if (!isLeafNode(chunk)) {\n        children = chunk.children\n            .map((c: NodeType) => {\n                const isList = isChildAList(c, LIST_TYPES);\n                const selfIsList = LIST_TYPES.includes(chunk.type ?? '');\n\n                // Links can have the following shape\n                // In which case we don't want to surround\n                // with break tags\n                // {\n                //  type: 'paragraph',\n                //  children: [\n                //    { text: '' },\n                //    { type: 'link', children: [{ text: foo.com }]}\n                //    { text: '' }\n                //  ]\n                // }\n                const childrenHasLink = doesChildHasALink(chunk, nodeTypes);\n\n                return process(\n                    { ...c, parentType: type },\n                    {\n                        nodeTypes,\n                        // WOAH.\n                        // what we're doing here is pretty tricky, it relates to the block below where\n                        // we check for ignoreParagraphNewline and set type to paragraph.\n                        // We want to strip out empty paragraphs sometimes, but other times we don't.\n                        // If we're the descendant of a list, we know we don't want a bunch\n                        // of whitespace. If we're parallel to a link we also don't want\n                        // to respect neighboring paragraphs\n                        ignoreParagraphNewline:\n                            (options.ignoreParagraphNewline || isList || selfIsList || childrenHasLink) &&\n                            // if we have c.break, never ignore empty paragraph new line\n                            !(c as BlockType).break,\n\n                        // track depth of nested lists so we can add proper spacing\n                        listDepth: getDepthOfNestedLists(LIST_TYPES, c, options.listDepth),\n                        linkDestinationKey: options.linkDestinationKey,\n                    },\n                );\n            })\n            .join('');\n    }\n\n    // This is pretty fragile code, check the long comment where we iterate over children\n    if (shouldIgnoreParagraphNewline(options.ignoreParagraphNewline, text, chunk, nodeTypes)) {\n        type = nodeTypes.paragraph;\n        children = BREAK_TAG;\n    }\n\n    if (children === '' && !IGNORE_ELEMENTS.find((k) => nodeTypes[k] === type)) {\n        return;\n    }\n\n    if (children !== BREAK_TAG && isLeafNode(chunk)) {\n        return applyFormattingToLeafNode(children, chunk);\n    }\n\n    return applyFormattingToBlockNode(options, children, chunk, options.listDepth, type, parentType);\n};\n\nexport default function serialize(opts?: PartialOptionType) {\n    const options = getSelectedOptions(opts);\n\n    return (tree: NodeType[]): string => tree.map((node) => process(node, options)).join('');\n}\n"],"names":["IGNORE_ELEMENTS","isChildAList","chunk","LIST_TYPES","isLeafNode","doesChildHasALink","nodeTypes","child","isMentionType","type","shouldIgnoreParagraphNewline","ignoreParagraphNewline","text","getDepthOfNestedLists","listTypes","children","listDepth","process","options","parentType","c","isList","selfIsList","childrenHasLink","BREAK_TAG","k","applyFormattingToLeafNode","applyFormattingToBlockNode","serialize","opts","getSelectedOptions","tree","node"],"mappings":";;;;AAQA,MAAMA,IAA+C,CAAC,iBAAiB,SAAS,SAAS,GAEnFC,IAAe,CAACC,GAAiBC,MAClCC,EAAWF,CAAK,IAA4C,KAAxCC,EAAW,SAASD,EAAM,QAAQ,EAAE,GAEvDG,IAAoB,CAACH,GAAiBI,MACxC,CAACF,EAAWF,CAAK,KAAK,MAAM,QAAQA,EAAM,QAAQ,IAC5CA,EAAM,SAAS;AAAA,EACX,CAACK,MAAU,CAACH,EAAWG,CAAK,MAAMA,EAAM,SAASD,EAAU,QAAQC,EAAM,SAASD,EAAU;AAChG,IACA,IAEJE,IAAgB,CAACC,GAAcH,MAA8BG,MAASH,EAAU,SAEhFI,IAA+B,CACjCC,GACAC,GACAV,GACAI,MAEA,CAACK,KACDC,MAAS;AAAA,KACTV,EAAM,eAAeI,EAAU,aAC/B,CAACE,EAAeN,EAAoB,MAAMI,CAAS,GAEjDO,IAAwB,CAACC,GAAqBC,GAAoBC,MACpEF,EAAU,SAAUC,EAAuB,QAAQ,EAAE,IAAIC,IAAY,IAAIA,GAEvEC,IAAU,CAACf,GAAiBgB,MAAwB;AACtD,QAAMZ,IAAYY,EAAQ,WACpBN,IAAQV,EAAmB,QAAQ;AACrC,MAAAO,IAAQP,EAAoB,QAAQ;AAClC,QAAAiB,IAAcjB,EAAoB,cAAc,QAChDC,IAAa,CAACG,EAAU,QAAQA,EAAU,MAAM;AACtD,MAAIS,IAAWH;AAoDX,MAlDCR,EAAWF,CAAK,MACjBa,IAAWb,EAAM,SACZ,IAAI,CAACkB,MAAgB;AACZ,UAAAC,IAASpB,EAAamB,GAAGjB,CAAU,GACnCmB,IAAanB,EAAW,SAASD,EAAM,QAAQ,EAAE,GAajDqB,IAAkBlB,EAAkBH,GAAOI,CAAS;AAEnD,WAAAW;AAAA,MACH,EAAE,GAAGG,GAAG,YAAYX,EAAK;AAAA,MACzB;AAAA,QACI,WAAAH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,QAQA,yBACKY,EAAQ,0BAA0BG,KAAUC,KAAcC;AAAA,QAE3D,CAAEH,EAAgB;AAAA;AAAA,QAGtB,WAAWP,EAAsBV,GAAYiB,GAAGF,EAAQ,SAAS;AAAA,QACjE,oBAAoBA,EAAQ;AAAA,MAChC;AAAA,IAAA;AAAA,EACJ,CACH,EACA,KAAK,EAAE,IAIZR,EAA6BQ,EAAQ,wBAAwBN,GAAMV,GAAOI,CAAS,MACnFG,IAAOH,EAAU,WACNS,IAAAS,IAGX,EAAAT,MAAa,MAAM,CAACf,EAAgB,KAAK,CAACyB,MAAMnB,EAAUmB,CAAC,MAAMhB,CAAI;AAIzE,WAAIM,MAAaS,KAAapB,EAAWF,CAAK,IACnCwB,EAA0BX,GAAUb,CAAK,IAG7CyB,EAA2BT,GAASH,GAAUb,GAAOgB,EAAQ,WAAWT,GAAMU,CAAU;AACnG;AAEA,SAAwBS,EAAUC,GAA0B;AAClD,QAAAX,IAAUY,EAAmBD,CAAI;AAEvC,SAAO,CAACE,MAA6BA,EAAK,IAAI,CAACC,MAASf,EAAQe,GAAMd,CAAO,CAAC,EAAE,KAAK,EAAE;AAC3F;"}