import { getLicElementClassNames as u } from "../../Plugins/ListPlugin/ListItemContentMarkupElement.es.js";
import { LI_CLASSNAMES as f, getLiStyles as N } from "../../Plugins/ListPlugin/ListItemMarkupElement.es.js";
import { isText as L, ELEMENT_UL as T, ELEMENT_OL as c, ELEMENT_LI as h, ELEMENT_LIC as g, ELEMENT_LINK as $, ELEMENT_MENTION as C } from "@udecode/plate";
import { merge as d } from "../../../../utilities/merge.es.js";
import { buttonNode as y } from "../nodes/button.es.js";
import { checkItemNode as M } from "../nodes/checkItem.es.js";
import { linkNode as _ } from "../nodes/link.es.js";
import { mentionHtmlNode as S } from "../nodes/mentionHtmlNode.es.js";
import { reactCssPropsToCss as n } from "./reactCssPropsToCss.es.js";
import { serializeLeafToHtml as k } from "./serializeLeafToHtml.es.js";
import { UL_CLASSES as I } from "../../Plugins/ListPlugin/UnorderedListPlugin/UnorderedListMarkupElement.es.js";
import { getOrderedListClasses as b, OL_STYLES as x } from "../../Plugins/ListPlugin/OrderedListPlugin/OrderedListMarkupElement.es.js";
import { ELEMENT_BUTTON as H, alignmentClassnames as O } from "../../Plugins/helper.es.js";
import { TextStyles as o } from "../../Plugins/TextStylePlugin/types.es.js";
import { ELEMENT_CHECK_ITEM as w } from "../../Plugins/CheckboxListPlugin/id.es.js";
const p = (t, e) => t.reduce((r, s) => (s.type === e && r++, s.children ? r + p(s.children, e) : r), 0), v = (t, e, { mappedMentionable: r, nestingCount: s = {} }) => {
  if (L(t))
    return k(t);
  const i = s[t.type] || p([t], t.type);
  let a = "";
  for (const l of t.children)
    a += v(l, e, {
      nestingCount: {
        ...s,
        [l.type]: i
      },
      mappedMentionable: r
    });
  const E = A[t.type];
  try {
    return E({
      classNames: U(
        t.breakAfterColumn,
        t.align
      ),
      children: a,
      rootNestingCount: i,
      node: t,
      mappedMentionable: r,
      styles: e
    }) ?? a;
  } catch {
    return console.warn(`The htmlMapper for node type: '${t.type}' does not exist.`), a;
  }
}, A = {
  [o.heading1]: (t) => m(o.heading1, t, "h1"),
  [o.heading2]: (t) => m(o.heading2, t, "h2"),
  [o.heading3]: (t) => m(o.heading3, t, "h3"),
  [o.heading4]: (t) => m(o.heading4, t, "h4"),
  [o.p]: (t) => m(o.p, t, "p"),
  [o.custom1]: (t) => m(o.custom1, t, "p"),
  [o.custom2]: (t) => m(o.custom2, t, "p"),
  [o.custom3]: (t) => m(o.custom3, t, "p"),
  [o.quote]: (t) => m(o.quote, t, "p"),
  [o.imageTitle]: (t) => m(o.imageTitle, t, "p"),
  [o.imageCaption]: (t) => m(o.imageCaption, t, "p"),
  [T]: (t) => `<ul class="${I} ${t.classNames}">${t.children}</ul>`,
  [c]: ({ classNames: t, children: e, node: r, rootNestingCount: s }) => {
    const i = Math.max(s - p([r], c), 0);
    return `<ol class="${b(i)} ${t}" style="${n(
      x
    )}">${e}</ol>`;
  },
  [h]: ({ classNames: t, children: e, node: r, styles: s }) => `<li class="${t} ${f}" style="${n(
    N(r, s)
  )}">${e}</li>`,
  [g]: ({ classNames: t, children: e, node: r }) => `<p class="${t} ${u(r)}"><span>${e}</span></p>`,
  [$]: ({ node: t, children: e, classNames: r, styles: s }) => _(t, e, r, s),
  [H]: ({ node: t, children: e, classNames: r, styles: s }) => y(t, e, r, s),
  [w]: ({ node: t, children: e, classNames: r, styles: s }) => M(t, e, r, s),
  [C]: ({ node: t, mappedMentionable: e }) => S(t, { mentionable: e })
}, m = (t, { classNames: e, styles: r, children: s }, i) => `<${i} class="${e}" style="${n(r[t])}">${s}</${i}>`, U = (t, e) => {
  const r = "tw-break-words", s = t === "active" ? "tw-break-after-column tw-break-inside-avoid-column" : "", i = e ? O[e] : "";
  return d([i, r, s]);
};
export {
  v as serializeNodeToHtmlRecursive
};
//# sourceMappingURL=serializeNodeToHtmlRecursive.es.js.map
