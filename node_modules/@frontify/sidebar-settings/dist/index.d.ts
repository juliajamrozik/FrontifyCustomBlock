import { AssetChooserObjectType } from '@frontify/app-bridge';
import { AssetChooserProjectType } from '@frontify/app-bridge';
import type { Color as Color_2 } from '@frontify/fondue';
import type { ColorRgb as ColorRgb_2 } from '@frontify/fondue';
import { FileExtension } from '@frontify/app-bridge';
import { FileExtensionSets } from '@frontify/app-bridge';
import { IconEnum } from '@frontify/fondue';
import { ReactElement } from 'react';
import type { SearchResult as SearchResult_2 } from '@frontify/fondue';

/**
 * Checks if value is a numeric value without unit and creates string from value with unit
 *
 * @param {Bundle} bundle Sidebar bundle object
 * @param {string} settingId Setting id
 * @param {('px'|'em'|'rem'|'%'|'s'|'ms')} [unit='px'] Unit
 * @returns {string} Set block value to string with unit
 */
export declare const appendUnit: <AppBridge = unknown>(bundle: Bundle<AppBridge>, settingId: string, unit?: Unit) => void;

export { AssetChooserObjectType }

export { AssetChooserProjectType }

export declare type AssetInputBlock<AppBridge> = {
    /**
     * The setting type.
     */
    type: 'assetInput';
    /**
     * Whether multiple assets can be selected.
     */
    multiSelection?: boolean;
    /**
     * Allowed project types for the asset chooser.
     */
    projectTypes?: AssetChooserProjectType[];
    /**
     * Allowed object types for the asset chooser.
     */
    objectTypes?: AssetChooserObjectType[];
    /**
     * The mode of the asset input.
     *
     * It allows to restrict usage of upload and asset chooser.
     */
    mode?: AssetInputMode;
    /**
     * The size of the input.
     */
    size?: 'small' | 'large' | AssetInputSize;
    /**
     * The allowed file extensions to be uploaded.
     */
    extensions?: (FileExtension | string)[];
    /**
     * Whether the file size should be hidden or not.
     */
    hideSize?: boolean;
    /**
     * Whether the file extension should be hidden or not.
     */
    hideExtension?: boolean;
} & BaseBlock<AppBridge, AssetInputValue | AssetInputValue['value']>;

export declare enum AssetInputMode {
    BrowseAndUpload = "BrowseAndUpload",
    UploadOnly = "UploadOnly",
    BrowseOnly = "BrowseOnly"
}

/**
 * @deprecated
 */
export declare enum AssetInputSize {
    Small = "Small",
    Large = "Large"
}

export declare enum AssetInputSource {
    Library = "Library",
    Upload = "Upload"
}

export declare type AssetInputValue = {
    source: AssetInputSource;
    value: number;
};

export declare type BaseBlock<AppBridge, T = undefined> = {
    /**
     * The unique identifier of the settings.
     *
     * This identifier will be the one used as a key in the different settings hooks.
     */
    id: string;
    /**
     * The label of the setting.
     */
    label?: ValueOrPromisedValue<AppBridge, string>;
    /**
     * Additionnal information about the settings to be shown in a tooltip.
     */
    info?: ValueOrPromisedValue<AppBridge, string>;
    /**
     * The current value of the setting.
     */
    value?: T;
    /**
     * The default value of the setting.
     */
    defaultValue?: T;
    /**
     * Whether the setting should be shown when translating the page or not.
     */
    showForTranslations?: boolean;
    /**
     * A function that determines whether the setting should be shown or not.
     */
    show?: (bundle: Bundle<AppBridge>) => boolean;
    /**
     * A function that is called when the setting value change.
     */
    onChange?: (bundle: Bundle<AppBridge>) => void;
};

/**
 * Rule to validate value is between two pixel values.
 *
 * @param {number} minimumValue Minimum value
 * @param {number} maximumValue Maximum value
 * @returns {Rule} Rule object with validator and error message.
 */
export declare const betweenNumericalOrPercentOrAutoRule: (minimumValue: number, maximumValue: number) => Rule<string>;

/**
 * Rule to validate value is between two percent values.
 *
 * @param {number} minimumValue Minimum value
 * @param {number} maximumValue Maximum value
 * @returns {Rule} Rule object with validator and error message.
 */
export declare const betweenPercentRule: (minimumValue: number, maximumValue: number) => Rule<string>;

/**
 * Rule to validate value is between two pixel values.
 *
 * @param {number} minimumValue Minimum value
 * @param {number} maximumValue Maximum value
 * @returns {Rule} Rule object with validator and error message.
 */
export declare const betweenPixelRule: (minimumValue: number, maximumValue: number) => Rule<string>;

export declare type Bundle<AppBridge> = {
    /**
     * A function which allows you to get the block value of a given id.
     * @param id Represent the setting id.
     * @returns The value of the setting.
     */
    getBlock: (id: string) => SettingValue<AppBridge> | null;
    /**
     * A function that returns an instance of the App Bridge.
     */
    getAppBridge: () => AppBridge;
    /**
     * A function that allows you to programmatically set the value for a block by its id.
     * @param id Represents the setting id.
     * @param value The new value to set.
     */
    setBlockValue: (id: string, value: SettingBlock<AppBridge>['value']) => void;
};

export declare type Checkbox = {
    /**
     * The unique identifier of the checkbox.
     *
     * This is the value you will receive when clicking the checkbox.
     */
    id: string;
    /**
     * The label for the checkbox.
     */
    label?: string;
    /**
     * Additional information about the settings to be shown in a tooltip.
     */
    info?: string;
    /**
     * The tooltip for the checkbox.
     * @deprecated
     */
    tooltip?: {
        /**
         * The content of the tooltip.
         */
        content: string;
    };
};

export declare type ChecklistBlock<AppBridge> = {
    /**
     * The setting type.
     */
    type: 'checklist';
    /**
     * The list of available choices in the checklist.
     */
    choices: ValueOrPromisedValue<AppBridge, Checkbox[]>;
    /**
     * Whether to show the clear and select all buttons or not.
     */
    showClearAndSelectAllButtons?: boolean;
    /**
     * The number of columns to display the checklist in.
     */
    columns?: 1 | 2;
} & BaseBlock<AppBridge, string[] | null>;

export declare type Choice = {
    /**
     * The label of the item.
     */
    label?: string | number;
    /**
     * The icon of the item.
     *
     * The full list of icons can be found here {@link https://github.com/Frontify/fondue/blob/beta/src/foundation/Icon/IconEnum.ts}
     */
    icon?: IconEnum | keyof typeof IconEnum | ReactElement;
    /**
     * The value of the item.
     */
    value: string | number;
};

export declare type ChoicesType<AppBridge> = {
    /**
     * The list of available choices in the setting.
     */
    choices: ValueOrPromisedValue<AppBridge, Choice[]>;
} & BaseBlock<AppBridge, string | number>;

export declare type Color = Color_2;

export declare type ColorFormats = Color | ColorRgb;

export declare type ColorInputBlock<AppBridge> = {
    /**
     * The setting type.
     */
    type: 'colorInput';
    /**
     * Whether the dropdown value should be clearable or not.
     *
     * It will set the value of the setting to `null` when clicked.
     */
    clearable?: boolean;
} & BaseBlock<AppBridge, ColorFormats>;

export declare type ColorRgb = ColorRgb_2;

export declare const createFooter: <Label extends string>(footer: Footer<Label>) => Footer<string>;

/**
 * @deprecated Use `type: 'segmentedControls'` instead.
 */
declare type DeprecatedSliderType = 'slider';

export declare type DropdownBlock<AppBridge> = {
    /**
     * The setting type.
     */
    type: 'dropdown';
    /**
     * Whether the dropdown should be disabled or not.
     */
    disabled?: boolean;
    /**
     * The placeholder to be shown in the dropdown.
     */
    placeholder?: string;
    /**
     * The size of the dropdown.
     */
    size?: 'small' | 'large' | DropdownSize;
    /**
     * Whether the dropdown value should be clearable or not.
     *
     * It will set the value of the setting to `null` when clicked.
     */
    clearable?: boolean;
} & ChoicesType<AppBridge>;

/**
 * @deprecated
 */
export declare enum DropdownSize {
    Small = "Small",
    Large = "Large"
}

export declare type DynamicSettingBlock<AppBridge, T extends DynamicSupportedBlock<AppBridge> = DynamicSupportedBlock<AppBridge>> = UnionOmit<T, 'value'> & {
    value?: DynamicSupportedBlock<AppBridge>['value'][];
    dynamic: {
        addButtonLabel: string;
    };
};

export declare type DynamicSupportedBlock<AppBridge> = InputBlock<AppBridge> | ColorInputBlock<AppBridge> | DropdownBlock<AppBridge>;

declare type ExtractVariables<T extends string> = T extends `${infer _Start}[${infer Variable}]${infer Rest}` ? Variable extends string ? Rest extends string ? `${Variable}` | ExtractVariables<Rest> : `${Variable}` : never : never;

export { FileExtension }

export { FileExtensionSets }

export declare type FontInputBlock<AppBridge> = {
    /**
     * The setting type.
     */
    type: 'fontInput';
    /**
     * The text to be displayed in the setting.
     * @default "Lorem Ipsum"
     */
    placeholder?: string;
} & BaseBlock<AppBridge, FontValue>;

/**
 * The origin of the font.
 */
export declare enum FontProvider {
    Google = "Google",
    Selfhosted = "Selfhosted",
    System = "System"
}

export declare type FontValue = {
    /**
     * The origin of the font.
     */
    fontProvider: FontProvider | `${FontProvider}`;
    /**
     * The identifier of the font family.
     */
    fontFamily: string | number;
    /**
     * The rgba-color of the text.
     */
    color?: {
        /**
         * The red value of the color (0-255).
         */
        red: number;
        /**
         * The green value of the color (0-255).
         */
        green: number;
        /**
         * The blue value of the color (0-255).
         */
        blue: number;
        /**
         * The alpha value of the color (0-1).
         */
        alpha?: number;
    } | null;
    /**
     * The weight of the font (100-1000, increment of 100).
     */
    weight: 100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900 | 1000;
    /**
     * The size of the font.
     */
    size?: string;
    /**
     * The letter spacing of the text.
     */
    letterSpacing?: string;
    /**
     * The line height of the text.
     */
    lineHeight?: string;
    /**
     * Whether the font should be uppercase or not.
     */
    uppercase: boolean;
    /**
     * Whether the font should be italic or not.
     */
    italic: boolean;
    /**
     * Whether the font should be underlined or not.
     */
    underline: boolean;
    /**
     * The rgba-color of the text on hover.
     */
    hoverColor?: {
        /**
         * The red value of the color (0-255).
         */
        red: number;
        /**
         * The green value of the color (0-255).
         */
        green: number;
        /**
         * The blue value of the color (0-255).
         */
        blue: number;
        /**
         * The alpha value of the color (0-1).
         */
        alpha?: number;
    } | null;
    /**
     * The background color of the text on hover.
     */
    hoverBackgroundColor?: {
        /**
         * The red value of the color (0-255).
         */
        red: number;
        /**
         * The green value of the color (0-255).
         */
        green: number;
        /**
         * The blue value of the color (0-255).
         */
        blue: number;
        /**
         * The alpha value of the color (0-1).
         */
        alpha?: number;
    } | null;
    /**
     * The weight of the font on hover (100-1000, increment of 100).
     */
    hoverWeight: 100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900 | 1000;
    /**
     * The size of the font on hover.
     */
    hoverSize?: string;
    /**
     * The letter spacing of the text on hover.
     */
    hoverLetterSpacing?: string;
    /**
     * The line height of the text on hover.
     */
    hoverLineHeight?: string;
    /**
     * Whether the font should be uppercase or not on hover.
     */
    hoverUppercase: boolean;
    /**
     * Whether the font should be italic or not on hover.
     */
    hoverItalic: boolean;
    /**
     * Whether the font should be underlined or not on hover.
     */
    hoverUnderline: boolean;
    /**
     * The color of the text when active.
     */
    activeColor?: {
        /**
         * The red value of the background color when active (0-255).
         */
        red: number;
        /**
         * The green value of the background color when active (0-255).
         */
        green: number;
        /**
         * The blue value of the background color when active (0-255).
         */
        blue: number;
        /**
         * The alpha value of the color when active (0-1).
         */
        alpha?: number;
    } | null;
    /**
     * The background color of the text when active.
     */
    activeBackgroundColor?: {
        /**
         * The red value of the background color when active (0-255).
         */
        red: number;
        /**
         * The green value of the background color when active (0-255).
         */
        green: number;
        /**
         * The blue value of the background color when active (0-255).
         */
        blue: number;
        /**
         * The alpha value of the background color when active (0-1).
         */
        alpha?: number;
    } | null;
    /**
     * The weight of the font when active (100-1000, increment of 100).
     */
    activeWeight: 100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900 | 1000;
    /**
     * The size of the font when active.
     */
    activeSize?: string;
    /**
     * The letter spacing of the text when active.
     */
    activeLetterSpacing?: string;
    /**
     * The line height of the text when active.
     */
    activeLineHeight?: string;
    /**
     * Whether the font should be uppercase or not when active.
     */
    activeUppercase: boolean;
    /**
     * Whether the font should be italic or not when active.
     */
    activeItalic: boolean;
    /**
     * Whether the font should be underlined or not when active.
     */
    activeUnderline: boolean;
};

export declare type Footer<Label extends string> = {
    label?: Label;
} & (LinkOrEvent | {
    replace?: ExtractVariables<Label> extends never ? never : Record<ExtractVariables<Label>, LinkOrEvent>;
});

export declare const generatePaddingString: (paddingSpiderInput: (string | null)[]) => string;

export { IconEnum }

export declare type InputBlock<AppBridge> = {
    /**
     * The setting type.
     */
    type: 'input';
    /**
     * The icon of the input.
     *
     * The full list of icons can be found here {@link https://github.com/Frontify/fondue/blob/beta/src/foundation/Icon/IconEnum.ts}
     */
    icon?: IconEnum | keyof typeof IconEnum | ReactElement;
    /**
     * The type of input (text, number, etc.).
     */
    inputType?: 'text' | 'password' | 'number' | TextInputType;
    /**
     * The placeholder text for the input.
     */
    placeholder?: string;
    /**
     * Whether the input can be cleared or not.
     */
    clearable?: boolean;
    /**
     * The list of validation rules for the input.
     */
    rules?: Rule<string>[];
} & BaseBlock<AppBridge, string>;

export declare type LegacyAssetInputBlock<AppBridge> = {
    type: 'legacyAssetInput';
    multiSelection?: boolean;
    extensions?: (FileExtension | string)[];
    projectTypes?: AssetChooserProjectType[];
    objectTypes?: AssetChooserObjectType[];
    mode?: LegacyAssetInputMode;
    size?: 'small' | 'large' | AssetInputSize;
} & BaseBlock<AppBridge, LegacyAssetInputValue | LegacyAssetInputValue['value']>;

export declare enum LegacyAssetInputMode {
    BrowseAndUpload = "BrowseAndUpload",
    UploadOnly = "UploadOnly",
    BrowseOnly = "BrowseOnly"
}

export declare enum LegacyAssetInputSource {
    Library = "Library",
    Upload = "Upload"
}

export declare type LegacyAssetInputValue = {
    source: LegacyAssetInputSource;
    value: number;
};

export declare type LegacyTemplateInputBlock<AppBridge> = {
    /**
     * The setting type.
     */
    type: 'legacyTemplateInput';
} & BaseBlock<AppBridge, number>;

export declare type LinkChooserBlock<AppBridge> = {
    /**
     * The setting type.
     */
    type: 'linkChooser';
    /**
     * The placeholder text for the link chooser.
     */
    placeholder?: string;
    /**
     * Whether the link should be opened in a new tab or not.
     */
    openInNewTab?: boolean;
    /**
     * Whether the link chooser is disabled or not.
     */
    disabled?: boolean;
    /**
     * Whether the link chooser can be cleared or not.
     */
    clearable?: boolean;
    required?: boolean;
} & BaseBlock<AppBridge, {
    link: SearchResult | null;
    openInNewTab: boolean | null;
}>;

declare type LinkOrEvent = {
    href: string;
    target?: '_self' | '_blank';
} | {
    event: NotificationFooterEvent;
};

export declare const maximumNumericalOrPercentOrAutoRule: (maximumValue: number) => Rule<string>;

export declare const maximumNumericalOrPercentRule: (maximumValue: number) => Rule<string>;

export declare const maximumNumericalOrPixelOrAutoRule: (maximumValue: number) => Rule<string>;

export declare const maximumNumericalRule: (max: number) => {
    errorMessage: string;
    validate: (value: string) => boolean;
};

export declare const minimumNumericalOrPercentOrAutoRule: (minimumValue: number) => Rule<string>;

export declare const minimumNumericalOrPercentRule: (minimumValue: number) => Rule<string>;

export declare const minimumNumericalOrPixelOrAutoRule: (minimumValue: number) => Rule<string>;

export declare const minimumNumericalRule: (min: number) => {
    errorMessage: string;
    validate: (value: string) => boolean;
};

export declare const minimumNumericRule: (minimumValue: number) => Rule<string>;

export declare const minimumPixelRule: (minimumValue: number) => Rule<string>;

export declare type MultiInputBlock<AppBridge> = {
    /**
     * The setting type.
     */
    type: 'multiInput';
    /**
     * The layout of the multi input.
     * @default 'columns'
     */
    layout?: 'columns' | 'spider' | MultiInputLayout;
    /**
     * The list of blocks that make up the multi-input.
     *
     * The currently supported blocks are `input`, `colorInput` or `dropdown`.
     */
    blocks: (Omit<InputBlock<AppBridge>, 'value'> | Omit<ColorInputBlock<AppBridge>, 'value'> | Omit<DropdownBlock<AppBridge>, 'value'>)[];
    /**
     * Whether the last item should expand to full width or not.
     */
    lastItemFullWidth?: boolean;
} & BaseBlock<AppBridge>;

/**
 * @deprecated
 */
export declare enum MultiInputLayout {
    Columns = "Columns",
    Spider = "Spider"
}

export declare type NotificationBlock<AppBridge> = {
    /**
     * The setting type.
     */
    type: 'notification';
    /**
     * The title of the notification.
     */
    title?: string;
    /**
     * The text of the notification.
     */
    text?: string;
    /**
     * @deprecated Use `footer` instead
     */
    link?: LinkOrEvent & {
        label?: string;
    };
    /**
     * The footer associated with the notification.
     */
    footer?: ReturnType<typeof createFooter> | (LinkOrEvent & {
        label?: string;
    });
    /**
     * Customization of the notification setting.
     */
    styles?: {
        /**
         * The type of notification.
         */
        type?: 'info' | 'warning' | 'negative' | 'positive' | NotificationStyleType;
        /**
         * Indicates if the notification should include an icon.
         */
        icon?: boolean;
        /**
         * The position of the divider in the notification.
         */
        divider?: 'top' | 'bottom' | 'both' | 'none' | NotificationBlockDividerPosition;
    };
} & BaseBlock<AppBridge>;

export declare enum NotificationBlockDividerPosition {
    Top = "Top",
    Bottom = "Bottom",
    Both = "Both",
    None = "None"
}

export declare type NotificationFooterEvent = 'design-settings.open' | 'general-settings.open';

export declare enum NotificationStyleType {
    Warning = "Warning",
    Negative = "Negative",
    Positive = "Positive",
    Info = "Info"
}

export declare const numericalOrPercentRule: Rule<string>;

export declare const numericalOrPixelOrAutoRule: Rule<string>;

/**
 * Rule to validate value is a number or a number string with "px".
 */
export declare const numericalOrPixelRule: Rule<string>;

export declare const pixelRule: Rule<string>;

/**
 * Sets value of custom input to predefined value from the Segmented Controls, if no custom value is set already
 *
 * @param {Bundle} bundle Sidebar bundle object
 * @param {string} segmentedControlsId Setting id of the segmentedControls
 * @param {string} inputId Setting id of the input
 * @param {Object} map Map of enum and values
 * @returns Set value of custom input to predefined value from the segmentedControls
 */
export declare const presetCustomValue: <AppBridge = unknown>(bundle: Bundle<AppBridge>, segmentedControlsId: string, inputId: string, map: Record<string, string>) => void;

export declare type Rule<T> = {
    errorMessage: string;
    validate: (value: T) => boolean;
};

export declare type SearchResult = SearchResult_2;

export declare type SectionHeadingBlock<AppBridge> = {
    /**
     * The setting type.
     */
    type: 'sectionHeading';
    /**
     * The list of blocks that make up the section.
     */
    blocks: SettingBlock<AppBridge>[];
    /**
     * A switch which can toggle the blocks on and off.
     * @default false
     */
    hasSwitch?: boolean;
} & BaseBlock<AppBridge, boolean>;

export declare type SegmentedControlsBlock<AppBridge> = {
    /**
     * The setting type.
     */
    type: 'segmentedControls' | DeprecatedSliderType;
    /**
     * The text under the segmented control to give more details.
     */
    helperText?: string;
} & ChoicesType<AppBridge>;

export declare type SettingBlock<AppBridge> = SimpleSettingBlock<AppBridge> | DynamicSettingBlock<AppBridge>;

export declare type SettingValue<AppBridge> = {
    value?: SettingBlock<AppBridge>['value'];
};

export declare type SimpleSettingBlock<AppBridge> = AssetInputBlock<AppBridge> | ChecklistBlock<AppBridge> | ColorInputBlock<AppBridge> | DropdownBlock<AppBridge> | FontInputBlock<AppBridge> | InputBlock<AppBridge> | LegacyAssetInputBlock<AppBridge> | LinkChooserBlock<AppBridge> | MultiInputBlock<AppBridge> | NotificationBlock<AppBridge> | SectionHeadingBlock<AppBridge> | SegmentedControlsBlock<AppBridge> | SwitchBlock<AppBridge> | TemplateInputBlock<AppBridge> | LegacyTemplateInputBlock<AppBridge> | TextareaBlock<AppBridge>;

export declare type SwitchBlock<AppBridge> = {
    /**
     * The setting type.
     */
    type: 'switch';
    /**
     * The label of the switch.
     */
    switchLabel?: string;
    /**
     * The list of blocks to show when the switch is active.
     */
    on?: SettingBlock<AppBridge>[];
    /**
     * The list of blocks to show when the switch is inactive.
     */
    off?: SettingBlock<AppBridge>[];
    /**
     * The size of the switch.
     */
    size?: 'small' | 'medium' | SwitchSize;
} & BaseBlock<AppBridge, boolean>;

/**
 * @deprecated
 */
export declare enum SwitchSize {
    Small = "Small",
    Medium = "Medium"
}

export declare type TemplateInputBlock<AppBridge> = {
    /**
     * The setting type.
     */
    type: 'templateInput';
} & BaseBlock<AppBridge, number>;

export declare type TextareaBlock<AppBridge> = {
    /**
     * The setting type.
     */
    type: 'textarea';
    /**
     * The placeholder text for the input.
     */
    placeholder?: string;
    /**
     * The list of validation rules for the input.
     */
    rules?: Rule<string>[];
} & BaseBlock<AppBridge, string>;

/**
 * @deprecated
 */
export declare enum TextInputType {
    Text = "text",
    Password = "password",
    Number = "number"
}

declare type UnionOmit<T, K extends string | number | symbol> = T extends unknown ? Omit<T, K> : never;

declare type Unit = 'px' | 'em' | 'rem' | '%' | 's' | 'ms';

export declare type ValueOrPromisedValue<AppBridge, FieldType> = FieldType | ((bundle: Bundle<AppBridge>) => FieldType) | ((bundle: Bundle<AppBridge>) => Promise<FieldType>);

export { }
