import { useState as g, useCallback as A, useEffect as D } from "react";
import { produce as m } from "immer";
const w = (e, t) => e.sort && t.sort ? e.sort - t.sort : 0, I = (e, t, o = { enabled: !0 }) => {
  const [i, a] = g(/* @__PURE__ */ new Map([])), [c, u] = g(!0), r = A(async () => {
    u(!0), a(await h(e, t)), u(!1);
  }, [e, t]);
  return D(() => {
    o.enabled && r();
  }, [o.enabled, r]), D(() => {
    const f = (s) => {
      for (const n of s.payload.pageIds)
        if (i.has(n)) {
          r();
          break;
        }
    }, d = (s) => {
      !i.has(s.documentPage.id) || s.categoryId || a(
        m((n) => {
          v(n, s.documentPage, s.position);
        })
      );
    }, l = ({ action: s, documentPage: n }) => {
      s === "update" && i.has(n.id) || s === "add" && n.documentId === t && !n.categoryId ? r() : (s === "delete" || s === "move") && i.has(n.id) && a(
        m((p) => {
          s === "move" ? y(p, n) : s === "delete" && p.delete(n.id);
        })
      );
    };
    return window.emitter.on("AppBridge:GuidelineDocumentPage:Action", l), window.emitter.on("AppBridge:GuidelineDocumentPageTargets:Action", f), window.emitter.on("AppBridge:GuidelineDocumentPage:MoveEvent", d), () => {
      window.emitter.off("AppBridge:GuidelineDocumentPage:Action", l), window.emitter.off("AppBridge:GuidelineDocumentPageTargets:Action", f), window.emitter.off("AppBridge:GuidelineDocumentPage:MoveEvent", d);
    };
  }, [t, r, i]), { documentPages: Array.from(i.values()), refetch: r, isLoading: c };
}, v = (e, t, o) => {
  if (!t.sort || !o)
    return e;
  const i = e.get(t.id), a = [...e.values()].sort(w);
  e.clear();
  let c = 1, u = !0;
  for (const r of a)
    r.id !== t.id && (i && c === o && (e.set(t.id, { ...i, sort: o }), u = !1), e.set(r.id, {
      ...r,
      sort: c
    }), c++);
  return i && u && e.set(t.id, { ...i, sort: c }), e;
}, y = (e, t) => {
  const o = [...e.values()];
  let i = !0;
  e.clear();
  for (const a of o)
    a.id !== t.id && (e.size === t.sort - 1 && (e.set(t.id, t), i = !1), e.set(a.id, a));
  return i && e.set(t.id, t), e;
}, h = async (e, t) => {
  const o = await e.getUncategorizedDocumentPagesByDocumentId(t);
  return new Map([...o].sort(w).map((i) => [i.id, i]));
};
export {
  I as useUncategorizedDocumentPages
};
//# sourceMappingURL=useUncategorizedDocumentPages.es.js.map
