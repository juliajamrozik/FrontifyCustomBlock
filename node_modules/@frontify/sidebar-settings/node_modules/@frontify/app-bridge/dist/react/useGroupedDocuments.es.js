import { useState as w, useCallback as y, useEffect as A } from "react";
import { produce as m } from "immer";
const P = (e, n) => e.sort && n.sort ? e.sort - n.sort : 0, M = (e, n, t = { enabled: !0 }) => {
  const [o, i] = w(/* @__PURE__ */ new Map([])), [f, d] = w(!0), c = y(async () => {
    d(!0), i(await I(e, n)), d(!1);
  }, [e, n]);
  return A(() => {
    t.enabled && c();
  }, [t.enabled, c]), A(() => {
    const a = (r) => {
      o.has(r.documentPage.documentId) && i(
        m((u) => {
          const s = `${r.action}-page`;
          return (g[s] || g.default)(u, r.documentPage);
        })
      );
    }, l = (r) => {
      o.has(r.documentCategory.documentId) && i(
        m((u) => {
          const s = `${r.action}-category`;
          return (g[s] || g.default)(u, r.documentCategory);
        })
      );
    }, D = (r) => {
      !o.has(r.document.id) || r.newGroupId !== n || i(
        m((u) => G(u, r.document, r.position, r.newGroupId))
      );
    }, p = ({ action: r, document: u }) => {
      (r === "update" || r === "move") && o.has(u.id) || r === "add" && u.documentGroupId === n ? c() : r === "delete" && o.has(u.id) && i(
        m((s) => {
          r === "delete" && s.delete(u.id);
        })
      );
    };
    return window.emitter.on("AppBridge:GuidelineDocument:Action", p), window.emitter.on("AppBridge:GuidelineDocumentTargets:Action", c), window.emitter.on("AppBridge:GuidelineDocument:DocumentPageAction", a), window.emitter.on("AppBridge:GuidelineDocument:DocumentCategoryAction", l), window.emitter.on("AppBridge:GuidelineDocument:MoveEvent", D), () => {
      window.emitter.off("AppBridge:GuidelineDocument:Action", p), window.emitter.off("AppBridge:GuidelineDocumentTargets:Action", c), window.emitter.off("AppBridge:GuidelineDocument:DocumentPageAction", a), window.emitter.off("AppBridge:GuidelineDocument:DocumentCategoryAction", l), window.emitter.off("AppBridge:GuidelineDocument:MoveEvent", D);
    };
  }, [n, o, t.enabled, c]), { documents: Array.from(o.values()), refetch: c, isLoading: f };
}, G = (e, n, t, o) => {
  if (!n.sort)
    return e;
  const i = e.get(n.id), f = [...e.values()].sort(P);
  e.clear();
  let d = 1, c = !0;
  for (const a of f)
    a.id === n.id || a.documentGroupId !== o || (i && d === t && (e.set(n.id, { ...i, sort: t }), c = !1), e.set(a.id, {
      ...a,
      sort: d
    }), d++);
  return i && c && e.set(n.id, { ...i, sort: d }), e;
}, b = (e, n) => {
  const t = e.get(n.documentId);
  if (!t)
    return e;
  const o = {
    ...t,
    numberOfUncategorizedDocumentPages: t.numberOfUncategorizedDocumentPages + 1
  };
  return e.set(t.id, o);
}, C = (e, n) => {
  const t = e.get(n.documentId);
  if (!t)
    return e;
  const o = {
    ...t,
    numberOfUncategorizedDocumentPages: t.numberOfUncategorizedDocumentPages - 1
  };
  return e.set(t.id, o);
}, B = (e, n) => {
  const t = e.get(n.documentId);
  if (!t)
    return e;
  const o = {
    ...t,
    numberOfDocumentPageCategories: t.numberOfDocumentPageCategories + 1
  };
  return e.set(t.id, o);
}, O = (e, n) => {
  const t = e.get(n.documentId);
  if (!t)
    return e;
  const o = {
    ...t,
    numberOfDocumentPageCategories: t.numberOfDocumentPageCategories - 1
  };
  return e.set(t.id, o);
}, g = {
  "add-page": b,
  "delete-page": C,
  "add-category": B,
  "delete-category": O,
  default: (e) => e
}, I = async (e, n) => {
  const t = await e.getDocumentsByDocumentGroupId(n);
  return new Map([...t].sort(P).map((o) => [o.id, o]));
};
export {
  M as useGroupedDocuments
};
//# sourceMappingURL=useGroupedDocuments.es.js.map
