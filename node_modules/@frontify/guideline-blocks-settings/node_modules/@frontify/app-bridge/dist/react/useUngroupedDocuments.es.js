import { useState as G, useCallback as y, useEffect as h } from "react";
import { produce as p } from "immer";
const f = (e, n) => e.sort && n.sort ? e.sort - n.sort : 0, z = (e, n = { enabled: !0 }) => {
  const [t, r] = G(/* @__PURE__ */ new Map([])), [m, d] = G(!0), c = y(async () => {
    d(!0), r(await M(e)), d(!1);
  }, [e]);
  return h(() => {
    n.enabled && c();
  }, [n.enabled, c]), h(() => {
    const i = (o) => {
      t.has(o.documentPage.documentId) && r(
        p((u) => {
          const g = `${o.action}-page`;
          return (D[g] || D.default)(u, o.documentPage);
        })
      );
    }, s = (o) => {
      t.has(o.documentCategory.documentId) && r(
        p((u) => {
          const g = `${o.action}-category`;
          return (D[g] || D.default)(u, o.documentCategory);
        })
      );
    }, a = (o) => {
      (o == null ? void 0 : o.action) === "update" && t.size > 0 && c();
    }, l = (o) => {
      !t.has(o.document.id) || o.newGroupId || o.document.documentGroupId || r(p((u) => B(u, o.document, o.position)));
    }, w = (o) => {
      r(p((u) => b(u, o == null ? void 0 : o.documentGroup, o.position)));
    }, A = ({ action: o, document: u }) => {
      (o === "update" || o === "move") && t.has(u.id) || o === "add" && !u.documentGroupId ? c() : o === "delete" && t.has(u.id) && r(
        p((g) => {
          o === "delete" && g.delete(u.id);
        })
      );
    };
    return window.emitter.on("AppBridge:GuidelineDocument:Action", A), window.emitter.on("AppBridge:GuidelineDocumentTargets:Action", c), window.emitter.on("AppBridge:GuidelineDocument:DocumentPageAction", i), window.emitter.on("AppBridge:GuidelineDocument:DocumentCategoryAction", s), window.emitter.on("AppBridge:GuidelineDocumentGroup:Action", a), window.emitter.on("AppBridge:GuidelineDocument:MoveEvent", l), window.emitter.on("AppBridge:GuidelineDocumentGroup:MoveEvent", w), () => {
      window.emitter.off("AppBridge:GuidelineDocument:Action", A), window.emitter.off("AppBridge:GuidelineDocumentTargets:Action", c), window.emitter.off("AppBridge:GuidelineDocument:DocumentPageAction", i), window.emitter.off("AppBridge:GuidelineDocument:DocumentCategoryAction", s), window.emitter.off("AppBridge:GuidelineDocumentGroup:Action", a), window.emitter.off("AppBridge:GuidelineDocument:MoveEvent", l), window.emitter.off("AppBridge:GuidelineDocumentGroup:MoveEvent", w);
    };
  }, [t, n.enabled, c]), { documents: Array.from(t.values()), refetch: c, isLoading: m };
}, B = (e, n, t) => {
  if (!n.sort || !t)
    return e;
  const r = n.sort, m = [...e.values()].sort(f), d = [];
  e.clear();
  for (const i of m) {
    if (i.id === n.id) {
      d.push({ ...i, sort: t });
      continue;
    }
    const s = i.sort ?? 0;
    let a = 0;
    t <= s && (a = r > s || r === 0 ? 1 : 0), d.push({ ...i, sort: s + a });
  }
  const c = [...d].sort(f);
  for (const i of c)
    e.set(i.id, i);
  return e;
}, b = (e, n, t) => {
  if (!n.sort)
    return e;
  const r = n.sort, m = [...e.values()].sort(f), d = [];
  e.clear();
  for (const i of m) {
    const s = i.sort ?? 0;
    let a = 0;
    t <= s && (a = r > s ? 1 : 0), d.push({ ...i, sort: s + a });
  }
  const c = [...d].sort(f);
  for (const i of c)
    e.set(i.id, i);
  return e;
}, C = (e, n) => {
  const t = e.get(n.documentId);
  if (!t)
    return e;
  const r = {
    ...t,
    numberOfUncategorizedDocumentPages: t.numberOfUncategorizedDocumentPages + 1
  };
  return e.set(t.id, r);
}, I = (e, n) => {
  const t = e.get(n.documentId);
  if (!t)
    return e;
  const r = {
    ...t,
    numberOfUncategorizedDocumentPages: t.numberOfUncategorizedDocumentPages - 1
  };
  return e.set(t.id, r);
}, E = (e, n) => {
  const t = e.get(n.documentId);
  if (!t)
    return e;
  const r = {
    ...t,
    numberOfDocumentPageCategories: t.numberOfDocumentPageCategories + 1
  };
  return e.set(t.id, r);
}, v = (e, n) => {
  const t = e.get(n.documentId);
  if (!t)
    return e;
  const r = {
    ...t,
    numberOfDocumentPageCategories: t.numberOfDocumentPageCategories - 1
  };
  return e.set(t.id, r);
}, D = {
  "add-page": C,
  "delete-page": I,
  "add-category": E,
  "delete-category": v,
  default: (e) => e
}, M = async (e) => {
  const n = await e.getUngroupedDocuments();
  return new Map([...n].sort(f).map((t) => [t.id, t]));
};
export {
  z as useUngroupedDocuments
};
//# sourceMappingURL=useUngroupedDocuments.es.js.map
