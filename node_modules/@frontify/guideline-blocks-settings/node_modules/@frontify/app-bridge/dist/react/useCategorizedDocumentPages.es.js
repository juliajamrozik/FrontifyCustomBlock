import { useState as g, useCallback as A, useEffect as D } from "react";
import { produce as m } from "immer";
const w = (e, t) => e.sort && t.sort ? e.sort - t.sort : 0, M = (e, t, o = { enabled: !0 }) => {
  const [i, n] = g(/* @__PURE__ */ new Map([])), [c, u] = g(!0), r = A(async () => {
    u(!0), n(await y(e, t)), u(!1);
  }, [e, t]);
  return D(() => {
    o.enabled && r();
  }, [o.enabled, r]), D(() => {
    const f = (s) => {
      for (const a of s.payload.pageIds)
        if (i.has(a)) {
          r();
          break;
        }
    }, l = (s) => {
      !i.has(s.documentPage.id) || !s.categoryId || n(
        m((a) => {
          v(a, s.documentPage, s.position);
        })
      );
    }, d = ({ action: s, documentPage: a }) => {
      s === "update" && i.has(a.id) || s === "add" && a.categoryId === t ? r() : (s === "delete" || s === "move") && i.has(a.id) && n(
        m((p) => {
          s === "move" ? h(p, a) : s === "delete" && p.delete(a.id);
        })
      );
    };
    return window.emitter.on("AppBridge:GuidelineDocumentPage:Action", d), window.emitter.on("AppBridge:GuidelineDocumentPageTargets:Action", f), window.emitter.on("AppBridge:GuidelineDocumentPage:MoveEvent", l), () => {
      window.emitter.off("AppBridge:GuidelineDocumentPage:Action", d), window.emitter.off("AppBridge:GuidelineDocumentPageTargets:Action", f), window.emitter.off("AppBridge:GuidelineDocumentPage:MoveEvent", l);
    };
  }, [t, r, i]), { documentPages: Array.from(i.values()), refetch: r, isLoading: c };
}, v = (e, t, o) => {
  if (!t.sort || !o)
    return e;
  const i = e.get(t.id), n = [...e.values()].sort(w);
  e.clear();
  let c = 1, u = !0;
  for (const r of n)
    r.id !== t.id && (i && c === o && (e.set(t.id, { ...i, sort: o }), u = !1), e.set(r.id, {
      ...r,
      sort: c
    }), c++);
  return i && u && e.set(t.id, { ...i, sort: c }), e;
}, h = (e, t) => {
  const o = [...e.values()];
  let i = !0;
  e.clear();
  for (const n of o)
    n.id !== t.id && (e.size === t.sort - 1 && (e.set(t.id, t), i = !1), e.set(n.id, n));
  return i && e.set(t.id, t), e;
}, y = async (e, t) => {
  const o = await e.getDocumentPagesByDocumentCategoryId(t);
  return new Map([...o].sort(w).map((i) => [i.id, i]));
};
export {
  M as useCategorizedDocumentPages
};
//# sourceMappingURL=useCategorizedDocumentPages.es.js.map
