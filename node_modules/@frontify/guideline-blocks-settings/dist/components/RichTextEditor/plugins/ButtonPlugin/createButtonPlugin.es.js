import { Plugin as e } from "@frontify/fondue";
import { createPluginFactory as n } from "@udecode/plate";
import { isValidUrl as u } from "../LinkPlugin/utils/url.es.js";
import { ButtonMarkupElement as s } from "./ButtonMarkupElement/index.es.js";
import { ButtonButton as a } from "./components/ButtonButton.es.js";
import { CustomFloatingButton as g } from "./components/FloatingButton/CustomFloatingButton.es.js";
import { withButton as l } from "./withButton.es.js";
import { BlockButtonStyles as m } from "./utils/styles.es.js";
const d = "button", p = "button-plugin", B = (i) => n({
  key: d,
  isElement: !0,
  isInline: !0,
  props: ({ element: t }) => ({
    nodeProps: { href: t == null ? void 0 : t.url, target: t == null ? void 0 : t.target }
  }),
  withOverrides: l,
  renderAfterEditable: g,
  options: {
    isUrl: u,
    rangeBeforeOptions: {
      matchString: " ",
      skipInvalid: !0,
      afterMatch: !0
    },
    triggerFloatingButtonHotkeys: "command+shift+k, ctrl+shift+k",
    appBridge: i
  },
  then: (t, { type: r }) => ({
    deserializeHtml: {
      rules: [
        {
          validNodeName: "A",
          validClassName: "btn"
        }
      ],
      getNode: (o) => ({
        type: r,
        url: o.getAttribute("href"),
        target: o.getAttribute("target") || "_blank"
      })
    }
  })
})();
class P extends e {
  constructor({ styles: t = m, ...r }) {
    super(p, {
      button: a,
      markupElement: new s(),
      ...r
    }), this.styles = {}, this.styles = t, this.appBridge = r == null ? void 0 : r.appBridge;
  }
  plugins() {
    return [B(this.appBridge)];
  }
}
export {
  p as BUTTON_PLUGIN,
  P as ButtonPlugin,
  d as ELEMENT_BUTTON,
  B as createButtonPlugin
};
//# sourceMappingURL=createButtonPlugin.es.js.map
