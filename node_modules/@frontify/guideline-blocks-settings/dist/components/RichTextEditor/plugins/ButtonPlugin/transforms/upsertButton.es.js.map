{"version":3,"file":"upsertButton.es.js","sources":["../../../../../../src/components/RichTextEditor/plugins/ButtonPlugin/transforms/upsertButton.ts"],"sourcesContent":["/* (c) Copyright Frontify Ltd., all rights reserved. */\n\nimport {\n    InsertNodesOptions,\n    PlateEditor,\n    TNode,\n    TNodeEntry,\n    UnwrapNodesOptions,\n    Value,\n    WrapNodesOptions,\n    findNode,\n    getAboveNode,\n    getEditorString,\n    getNodeLeaf,\n    getNodeProps,\n    getPluginOptions,\n    getPluginType,\n    isDefined,\n    isExpanded,\n    removeNodes,\n    setNodes,\n} from '@udecode/plate';\nimport { Path } from 'slate';\nimport { ButtonPlugin, ELEMENT_BUTTON } from '../createButtonPlugin';\nimport { RichTextButtonStyle, TButtonElement } from '../types';\nimport { CreateButtonNodeOptions } from '../utils/index';\nimport { insertButton, unwrapButton, upsertButtonText, wrapButton } from '.';\n\nexport type UpsertButtonOptions<V extends Value = Value> = CreateButtonNodeOptions & {\n    /**\n     * If true, insert text when selection is in url.\n     */\n    insertTextInButton?: boolean;\n    insertNodesOptions?: InsertNodesOptions<V>;\n    unwrapNodesOptions?: UnwrapNodesOptions<V>;\n    wrapNodesOptions?: WrapNodesOptions<V>;\n    isUrl?: (url: string) => boolean;\n};\n\n/**\n * If selection in a button or is not url:\n * - insert text with url, exit\n * If selection is expanded or `update` in a button:\n * - remove button node, get button text\n * Then:\n * - insert button node\n */\nexport const upsertButton = <V extends Value>(\n    editor: PlateEditor<V>,\n    {\n        url,\n        text,\n        buttonStyle,\n        target,\n        insertTextInButton,\n        insertNodesOptions,\n        isUrl = getPluginOptions<ButtonPlugin, V>(editor, ELEMENT_BUTTON).isUrl,\n    }: UpsertButtonOptions<V>,\n) => {\n    const at = editor.selection;\n    if (!at) {\n        return;\n    }\n\n    const buttonAbove = getAboveNode<TButtonElement>(editor, {\n        at,\n        match: { type: getPluginType(editor, ELEMENT_BUTTON) },\n    });\n\n    // anchor and focus in button -> insert text\n    if (insertTextInButton && buttonAbove) {\n        // we don't want to insert marks in buttons\n        editor.insertText(url);\n        return true;\n    }\n\n    if (!isUrl?.(url)) {\n        return;\n    }\n\n    if (isDefined(text) && text.length === 0) {\n        text = url;\n    }\n\n    if (buttonAbove) {\n        editButtonUrlAndTarget<V>(url, editor, buttonAbove, target, buttonStyle, text);\n        return true;\n    }\n\n    // selection contains at one edge edge or between the edges\n    const buttonEntry = findNode<TButtonElement>(editor, {\n        at,\n        match: { type: getPluginType(editor, ELEMENT_BUTTON) },\n    });\n\n    const [buttonNode, buttonPath] = buttonEntry ?? [];\n\n    const shouldReplaceText = shouldReplaceButtonText<V>(editor, buttonPath, text);\n\n    if (isExpanded(at)) {\n        anchorAndFocusInButton<V>(buttonAbove, editor, url, buttonStyle, target, text);\n        return true;\n    }\n\n    if (shouldReplaceText) {\n        removeNodes(editor, {\n            at: buttonPath,\n        });\n    }\n\n    const props = getNodeProps(buttonNode ?? ({} as TNode));\n\n    const path = editor.selection?.focus.path;\n    if (!path) {\n        return;\n    }\n\n    // button text should have the focused leaf marks\n    const leaf = getNodeLeaf(editor, path);\n\n    // if text is empty, text is url\n    if (!text?.length) {\n        text = url;\n    }\n\n    insertButton(\n        editor,\n        {\n            ...props,\n            url,\n            target,\n            children: [\n                {\n                    ...leaf,\n                    text,\n                },\n            ],\n        },\n        insertNodesOptions,\n    );\n    return true;\n};\n\nfunction shouldReplaceButtonText<V extends Value>(editor: PlateEditor<V>, buttonPath?: Path, text?: string) {\n    return buttonPath && text?.length && text !== getEditorString(editor, buttonPath);\n}\n\nfunction anchorAndFocusInButton<V extends Value>(\n    buttonAbove: undefined,\n    editor: PlateEditor<V>,\n    url: string,\n    buttonStyle?: RichTextButtonStyle,\n    target?: string,\n    text?: string,\n) {\n    if (buttonAbove) {\n        unwrapButton(editor, {\n            at: buttonAbove[1],\n        });\n    } else {\n        unwrapButton(editor, {\n            split: true,\n        });\n    }\n\n    wrapButton(editor, {\n        url,\n        buttonStyle,\n        target,\n    });\n\n    upsertButtonText(editor, { url, target, text });\n}\n\nfunction editButtonUrlAndTarget<V extends Value>(\n    url: string,\n    editor: PlateEditor<V>,\n    buttonAbove: TNodeEntry<TButtonElement>,\n    target?: string,\n    buttonStyle?: string,\n    text?: string,\n) {\n    if (\n        url !== buttonAbove[0]?.url ||\n        target !== buttonAbove[0]?.target ||\n        buttonStyle !== buttonAbove[0]?.buttonStyle\n    ) {\n        setNodes<TButtonElement>(\n            editor,\n            { url, target, buttonStyle },\n            {\n                at: buttonAbove[1],\n            },\n        );\n    }\n\n    upsertButtonText(editor, { url, text, target });\n}\n"],"names":["upsertButton","editor","url","text","buttonStyle","target","insertTextInButton","insertNodesOptions","isUrl","getPluginOptions","ELEMENT_BUTTON","at","buttonAbove","getAboveNode","getPluginType","isDefined","editButtonUrlAndTarget","buttonEntry","findNode","buttonNode","buttonPath","shouldReplaceText","shouldReplaceButtonText","isExpanded","anchorAndFocusInButton","removeNodes","props","getNodeProps","path","_a","leaf","getNodeLeaf","insertButton","getEditorString","unwrapButton","wrapButton","upsertButtonText","_b","_c","setNodes"],"mappings":";;;;;;AA+Ca,MAAAA,IAAe,CACxBC,GACA;AAAA,EACI,KAAAC;AAAA,EACA,MAAAC;AAAA,EACA,aAAAC;AAAA,EACA,QAAAC;AAAA,EACA,oBAAAC;AAAA,EACA,oBAAAC;AAAA,EACA,OAAAC,IAAQC,EAAkCR,GAAQS,CAAc,EAAE;AACtE,MACC;;AACD,QAAMC,IAAKV,EAAO;AAClB,MAAI,CAACU;AACD;AAGE,QAAAC,IAAcC,EAA6BZ,GAAQ;AAAA,IACrD,IAAAU;AAAA,IACA,OAAO,EAAE,MAAMG,EAAcb,GAAQS,CAAc,EAAE;AAAA,EAAA,CACxD;AAGD,MAAIJ,KAAsBM;AAEtB,WAAAX,EAAO,WAAWC,CAAG,GACd;AAGP,MAAA,EAACM,KAAA,QAAAA,EAAQN;AACT;AAOJ,MAJIa,EAAUZ,CAAI,KAAKA,EAAK,WAAW,MAC5BA,IAAAD,IAGPU;AACA,WAAAI,EAA0Bd,GAAKD,GAAQW,GAAaP,GAAQD,GAAaD,CAAI,GACtE;AAIL,QAAAc,IAAcC,EAAyBjB,GAAQ;AAAA,IACjD,IAAAU;AAAA,IACA,OAAO,EAAE,MAAMG,EAAcb,GAAQS,CAAc,EAAE;AAAA,EAAA,CACxD,GAEK,CAACS,GAAYC,CAAU,IAAIH,KAAe,CAAA,GAE1CI,IAAoBC,EAA2BrB,GAAQmB,GAAYjB,CAAI;AAEzE,MAAAoB,EAAWZ,CAAE;AACb,WAAAa,EAA0BZ,GAAaX,GAAQC,GAAKE,GAAaC,GAAQF,CAAI,GACtE;AAGX,EAAIkB,KACAI,EAAYxB,GAAQ;AAAA,IAChB,IAAImB;AAAA,EAAA,CACP;AAGL,QAAMM,IAAQC,EAAaR,KAAe,CAAY,CAAA,GAEhDS,KAAOC,IAAA5B,EAAO,cAAP,gBAAA4B,EAAkB,MAAM;AACrC,MAAI,CAACD;AACD;AAIE,QAAAE,IAAOC,EAAY9B,GAAQ2B,CAAI;AAGjC,SAACzB,KAAA,QAAAA,EAAM,WACAA,IAAAD,IAGX8B;AAAA,IACI/B;AAAA,IACA;AAAA,MACI,GAAGyB;AAAA,MACH,KAAAxB;AAAA,MACA,QAAAG;AAAA,MACA,UAAU;AAAA,QACN;AAAA,UACI,GAAGyB;AAAA,UACH,MAAA3B;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ;AAAA,IACAI;AAAA,EAAA,GAEG;AACX;AAEA,SAASe,EAAyCrB,GAAwBmB,GAAmBjB,GAAe;AACxG,SAAOiB,MAAcjB,KAAA,gBAAAA,EAAM,WAAUA,MAAS8B,EAAgBhC,GAAQmB,CAAU;AACpF;AAEA,SAASI,EACLZ,GACAX,GACAC,GACAE,GACAC,GACAF,GACF;AACE,EAAIS,IACAsB,EAAajC,GAAQ;AAAA,IACjB,IAAIW,EAAY,CAAC;AAAA,EAAA,CACpB,IAEDsB,EAAajC,GAAQ;AAAA,IACjB,OAAO;AAAA,EAAA,CACV,GAGLkC,EAAWlC,GAAQ;AAAA,IACf,KAAAC;AAAA,IACA,aAAAE;AAAA,IACA,QAAAC;AAAA,EAAA,CACH,GAED+B,EAAiBnC,GAAQ,EAAE,KAAAC,GAAK,QAAAG,GAAQ,MAAAF,EAAM,CAAA;AAClD;AAEA,SAASa,EACLd,GACAD,GACAW,GACAP,GACAD,GACAD,GACF;;AACE,GACID,QAAQ2B,IAAAjB,EAAY,CAAC,MAAb,gBAAAiB,EAAgB,QACxBxB,QAAWgC,IAAAzB,EAAY,CAAC,MAAb,gBAAAyB,EAAgB,WAC3BjC,QAAgBkC,IAAA1B,EAAY,CAAC,MAAb,gBAAA0B,EAAgB,iBAEhCC;AAAA,IACItC;AAAA,IACA,EAAE,KAAAC,GAAK,QAAAG,GAAQ,aAAAD,EAAY;AAAA,IAC3B;AAAA,MACI,IAAIQ,EAAY,CAAC;AAAA,IACrB;AAAA,EAAA,GAIRwB,EAAiBnC,GAAQ,EAAE,KAAAC,GAAK,MAAAC,GAAM,QAAAE,EAAQ,CAAA;AAClD;"}