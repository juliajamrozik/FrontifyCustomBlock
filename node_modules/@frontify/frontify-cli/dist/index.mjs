#!/usr/bin/env node
import { cac as A } from "cac";
import w from "prompts";
import { exit as E } from "node:process";
import { resolve as m, join as l } from "node:path";
import { URL as V, fileURLToPath as H } from "node:url";
import u from "picocolors";
import S from "@vitejs/plugin-react";
import { build as Y, createServer as M } from "vite";
import { viteExternalsPlugin as C } from "vite-plugin-externals";
import z from "conf";
import { readdirSync as T, mkdirSync as q, statSync as K, copyFileSync as G, readFileSync as v, writeFileSync as W } from "node:fs";
import X from "glob-to-regexp";
import "node:crypto";
import Q from "node-fetch";
import { exec as Z } from "node:child_process";
import "archiver";
import ee from "fast-glob";
import U from "open";
import te from "fastify";
import re from "@fastify/cors";
const ne = async (t, e, r) => Y({
  plugins: [
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    //@ts-ignore
    S(),
    C({
      react: "React",
      "react-dom": "ReactDOM"
    })
  ],
  define: {
    "process.env.NODE_ENV": JSON.stringify("production")
  },
  root: t,
  build: {
    lib: {
      name: r,
      entry: e,
      formats: ["iife"],
      fileName: () => "index.js"
    },
    rollupOptions: {
      external: ["react", "react-dom"],
      output: {
        globals: {
          react: "React",
          "react-dom": "ReactDOM"
        },
        footer: `window.${r} = ${r};`
      }
    }
  }
});
class h {
  static set(e, r) {
    this.conf.set(e, r);
  }
  static get(e) {
    return this.conf.get(e, void 0);
  }
  static delete(e) {
    return this.conf.delete(e);
  }
}
h.conf = new z({
  projectName: "frontify-cli"
});
const g = () => {
  const t = /* @__PURE__ */ new Date();
  return `${String(t.getHours()).padStart(2, "0")}:${String(t.getMinutes()).padStart(2, "0")}:${String(
    t.getSeconds()
  ).padStart(2, "0")}`;
};
class n {
  static defaultInfo(...e) {
    console.log(n.spacer(10), ...e);
  }
  static info(...e) {
    console.log(`[${g()}] ${e.join(" ")}`);
  }
  static success(...e) {
    console.log(`[${g()}] ${u.green(e.join(" "))}`);
  }
  static error(...e) {
    console.error(u.red(`[${g()}] ${e.join(" ")}`));
  }
  static spacer(e = 1) {
    return Array(e + 1).join(" ");
  }
}
class y extends Error {
  constructor(e) {
    super(), this.name = "FileNotFoundError", n.error(`The file at "${e}" was not found.`);
  }
}
const oe = (t) => {
  try {
    return T(t).length === 0;
  } catch {
    return !0;
  }
}, I = (t, e, r) => {
  q(e, { recursive: !0 });
  const o = r == null ? void 0 : r.exclude.map((s) => X(s));
  for (const s of T(t)) {
    if (o !== void 0 && o.some((c) => c.test(s)))
      continue;
    const a = m(t, s), i = m(e, s);
    se(a, i);
  }
}, se = (t, e) => {
  K(t).isDirectory() ? I(t, e) : G(t, e);
}, ae = (t) => {
  try {
    return v(t, "utf-8");
  } catch {
    throw new y(t);
  }
}, ie = (t) => {
  try {
    return v(t, "base64");
  } catch {
    throw new y(t);
  }
}, ce = (t) => {
  try {
    return ae(t).split(/\r?\n/).filter((r) => r !== "");
  } catch {
    throw new y(t);
  }
};
class le extends Error {
  constructor(e, r) {
    super(`Status code ${e}`), this.code = 0, this.name = "HttpClientError", this.code = e, this.responseBody = r;
  }
}
class b {
  constructor(e) {
    this.baseUrl = e.replace(/^https?:\/\//, "");
  }
  async fetchExtended({ method: e, url: r, body: o, options: s }) {
    const a = await Q(this.getAbsoluteUrl(r), {
      method: e,
      ...o && {
        body: JSON.stringify(o)
      },
      ...s,
      headers: { "Content-Type": "application/json", ...s == null ? void 0 : s.headers }
    });
    if (a.status === 200)
      switch (a.headers.get("Content-Type")) {
        case "application/json":
          const c = await a.json();
          return c || void 0;
        default:
          const f = await a.text();
          return f || void 0;
      }
    else {
      const i = await a.json();
      throw new le(a.status, i);
    }
  }
  get(e, r) {
    return this.fetchExtended({ url: e, method: "GET", options: r });
  }
  post(e, r, o) {
    return this.fetchExtended({ url: e, method: "POST", body: r, options: o });
  }
  put(e, r, o) {
    return this.fetchExtended({ url: e, method: "PUT", body: r, options: o });
  }
  delete(e, r) {
    return this.fetchExtended({ url: e, method: "DELETE", options: r });
  }
  getAbsoluteUrl(e) {
    return `https://${this.baseUrl}${e}`;
  }
}
class pe extends Error {
  constructor(e) {
    super(), this.name = "ParseJsonError", n.error(`The file at "${e}" could not be parsed.`);
  }
}
const F = (t) => {
  try {
    const e = v(t, "utf8"), r = JSON.parse(e);
    return new Proxy(r, {
      set: (o, s, a) => {
        o[s] = a;
        const i = JSON.stringify(o, null, "	");
        return W(t, i), !0;
      }
    });
  } catch (e) {
    throw e instanceof SyntaxError ? new pe(t) : e.code === "ENOENT" ? new y(t) : new Error(e);
  }
}, de = (t) => {
  const e = m(t, "package.json"), r = F(e);
  r.name = t;
}, ue = (t) => t ? /^[_a-z-]+$/.test(t) ? oe(t) ? !0 : `The directory ./${t} already exist.` : 'The project name needs to be "a-z" separated by "-" or "_".' : "The content block name can not be empty.";
class he extends Error {
  constructor(e) {
    super(), this.name = "CommandExecutionError", n.error(`The command execution failed: ${e}`);
  }
}
const k = (t, e = {}) => new Promise((r, o) => {
  Z(t, e, (s, a) => s ? o(new he(s + a)) : r(a));
});
class fe extends Error {
  constructor(e) {
    super(), this.name = "InvalidInstanceUrlError", e ? n.error(`The given URL "${e}" is invalid.`) : n.error("No instance URL was given.");
  }
}
const P = (t) => {
  try {
    const e = t.replace(/^https?:\/\//, "");
    return new V(`https://${e}`).hostname;
  } catch {
    throw new fe(t);
  }
}, R = async (t) => {
  const e = new b(t), r = h.get("tokens.access_token");
  try {
    return (await e.post(
      "/graphql",
      { query: "{ currentUser { email name } }" },
      { headers: { Authorization: `Bearer ${r}` } }
    )).data.currentUser;
  } catch {
    n.error(`You are not logged in, you can use the command ${u.bold("frontify-cli login")}.`);
    return;
  }
}, me = "content-block-", _ = (t, e = "tailwind") => {
  n.info("Creating the content block...");
  const r = u.blue(`./${t}`);
  n.info(`Scaffholding content block in ${r}...`);
  const o = m(H(import.meta.url), `../../templates/${me}${e}`);
  I(o, t, { exclude: ["node_modules"] }), de(t), n.defaultInfo(`
${n.spacer(11)}You can now access the project and install dependencies.`);
  const s = u.blue(`./${t}`);
  n.defaultInfo(`${n.spacer(4)}cd ${s}`), n.defaultInfo(`${n.spacer(4)}npm i`), n.defaultInfo(`${n.spacer(4)}npm run serve`), n.defaultInfo(`
${n.spacer(11)}Happy hacking!`);
}, $ = async (t, e) => {
  const r = await ee(l(t, "**"), { ignore: e, dot: !0 });
  return r.map((s) => s.replace(`${t}/`, "")).reduce((s, a, i) => (s[`/${a}`] = ie(r[i]), s), {});
}, ye = ["**/*.*.map"], ge = [".git", "node_modules", "dist", ".vscode", ".idea", "README.md", ".DS_Store"], D = async (t, e, { dryRun: r = !1, noVerify: o = !1, openInBrowser: s = !1 }) => {
  try {
    let a;
    const i = h.get("instanceUrl");
    if (i || (n.error(`You are not logged in, you can use the command ${u.bold("frontify-cli login")}.`), process.exit(-1)), r || (a = await R(i), a && n.info(`You are logged in as ${a.name} (${i}).`)), a || r) {
      r && n.info(u.blue("Dry run: enabled"));
      const c = process.cwd(), f = F(l(c, "manifest.json"));
      o || (n.info("Performing type checks..."), await k("npx tsc --noEmit"), n.info("Performing eslint checks..."), await k("npx eslint src"));
      try {
        await ne(c, t, f.appId);
      } catch (d) {
        n.error(d), process.exit(-1);
      }
      const j = ye.map((d) => l(c, d)), N = [...ce(l(c, ".gitignore")), ...ge].map(
        (d) => l(c, d)
      ), L = {
        build_files: await $(l(c, e), j),
        source_files: await $(l(c), N)
      };
      if (r)
        n.success("The command has been executed without any issue."), process.exit(0);
      else {
        n.info("Sending the files to Frontify Marketplace...");
        const d = new b(i), B = h.get("tokens.access_token");
        try {
          await d.put(`/api/marketplace/app/${f.appId}`, L, {
            headers: { Authorization: `Bearer ${B}` }
          }), n.success("The new version has been pushed."), s && (n.info("Opening the Frontify Marketplace page..."), await U(`https://${i}/marketplace/apps/${f.appId}`));
        } catch (J) {
          n.error("An error occured while deploying:", J.responseBody.error), process.exit(-1);
        }
      }
    }
  } catch (a) {
    n.error("The deployment has failed and was aborted due to an error:", a), process.exit(-1);
  }
};
class we {
  constructor(e, r = 5600) {
    this.fastifyServer = te(), this.instanceUrl = e, this.port = r, this.httpClient = new b(e);
  }
  serveCallbackServer() {
    this.registerPlugins(), this.registerRoutes(), this.fastifyServer.listen({ port: this.port });
  }
  registerRoutes() {
    this.fastifyServer.get("/oauth", async (e, r) => {
      n.info("Access granted, getting access token..."), r.send("You can close this window.");
      const o = await this.getOauthCredentialDetails(e.query.code);
      n.info("Tokens received, storing tokens..."), h.set("tokens", o), h.set("instanceUrl", this.instanceUrl);
      const s = await R(this.instanceUrl);
      s && n.success(`${`Welcome back ${s.name} (${this.instanceUrl})!`}`), process.exit(0);
    });
  }
  registerPlugins() {
    this.fastifyServer.register(re);
  }
  async storeRandomCodeChallenge() {
    try {
      const e = await this.httpClient.get(
        "/api/oauth/random"
      );
      this.randomChallenge = e.data;
    } catch {
      throw new Error("An error occured while getting the random challenge.");
    }
  }
  getLoginUrl() {
    if (!this.randomChallenge)
      throw new Error("Random challenge needs to be defined");
    const e = [
      "response_type=code",
      "client_id=block-cli",
      "redirect_uri=http://localhost:5600/oauth",
      "scope=basic:read%2Bblocks:read%2Bblocks:write",
      `code_challenge=${this.randomChallenge.sha256}`,
      "code_challenge_method=S256"
    ].join("&");
    return `https://${this.instanceUrl}/api/oauth/authorize?${e}`;
  }
  async getOauthCredentialDetails(e) {
    if (!this.randomChallenge)
      throw new Error("Random challenge needs to be defined");
    try {
      return await this.httpClient.post("/api/oauth/accesstoken", {
        grant_type: "authorization_code",
        client_id: "block-cli",
        redirect_uri: "http://localhost:5600/oauth",
        scope: "basic:read%2Bblocks:read%2Bblocks:write",
        code_verifier: this.randomChallenge.secret,
        code: e
      });
    } catch (r) {
      throw new Error(`An error occured while getting tokens: ${r.message}`);
    }
  }
}
const ve = async (t, e) => {
  try {
    const r = P(t), o = new we(r, e);
    o.serveCallbackServer(), await o.storeRandomCodeChallenge();
    const s = o.getLoginUrl();
    n.info("Attempting to open OAuth login page..."), n.info(
      `If a browser window doesn't automatically open, please open the following link manually: ${s}`
    ), await U(s);
  } catch {
    n.error("You need to enter a valid Frontify instance URL."), process.exit(-1);
  }
}, be = () => {
  h.delete("tokens"), n.info("You are now logged out.");
}, xe = "@frontify/frontify-cli", ke = "Frontify Developers <developers@frontify.com>", $e = "5.3.16", Ee = {
  "frontify-cli": "dist/index.mjs"
}, Se = {
  node: ">=16"
}, Ce = {
  type: "git",
  url: "https://github.com/Frontify/brand-sdk",
  directory: "packages/cli"
}, Te = [
  "dist",
  "templates"
], Ue = "module", Ie = {
  build: "vite build",
  format: "prettier --write .",
  lint: "eslint .",
  "lint:fix": "eslint --fix .",
  start: "npm run build && node dist/index.mjs",
  test: "vitest run --silent",
  "test:watch": "vitest",
  "test:coverage": "vitest run --coverage",
  "test:ui": "vitest --ui",
  typecheck: "tsc --noEmit"
}, Fe = {
  "@fastify/cors": "^8.3.0",
  "@vitejs/plugin-react": "^4.0.4",
  archiver: "^5.3.1",
  cac: "^6.7.14",
  conf: "^11.0.2",
  "fast-glob": "^3.3.1",
  fastify: "^4.21.0",
  "glob-to-regexp": "^0.4.1",
  "node-fetch": "^3.3.2",
  open: "^9.1.0",
  picocolors: "^1.0.0",
  prompts: "^2.4.2",
  vite: "^4.4.9",
  "vite-plugin-externals": "^0.6.2"
}, Pe = {
  "@frontify/eslint-config-typescript": "^0.16.1",
  "@types/glob-to-regexp": "^0.4.1",
  "@types/mock-fs": "^4.13.1",
  "@types/node": "^18.17.4",
  "@types/prompts": "^2.4.4",
  "@types/ws": "8.5.5",
  "@vitest/coverage-c8": "^0.33.0",
  "@vitest/ui": "^0.34.1",
  eslint: "^8.46.0",
  "eslint-plugin-notice": "^0.9.10",
  "mock-fs": "^5.2.0",
  nock: "^13.3.2",
  prettier: "^3.0.1",
  "ts-node": "^10.9.1",
  typescript: "^5.1.6",
  vitest: "^0.34.1"
}, x = {
  name: xe,
  author: ke,
  version: $e,
  bin: Ee,
  engines: Se,
  repository: Ce,
  files: Te,
  type: Ue,
  scripts: Ie,
  dependencies: Fe,
  devDependencies: Pe
};
class Re {
  constructor(e, r, o) {
    this.entryFilePath = e, this.port = r, this.allowExternal = o;
  }
  async serve() {
    try {
      const e = await M({
        root: process.cwd(),
        plugins: [
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          //@ts-ignore
          S(),
          C({
            react: "React",
            "react-dom": "ReactDOM"
          })
        ],
        define: {
          "process.env.NODE_ENV": JSON.stringify("development")
        },
        base: `http://localhost:${this.port}/`,
        appType: "custom",
        server: {
          port: this.port,
          host: this.allowExternal ? "0.0.0.0" : "localhost",
          cors: !0,
          hmr: {
            port: this.port,
            host: this.allowExternal ? "0.0.0.0" : "localhost",
            protocol: "ws"
          }
        }
      });
      e.middlewares.use("/", (o, s, a) => o.url !== "/" ? a() : (s.writeHead(200), s.end("OK"))), e.middlewares.use("/_entrypoint", (o, s, a) => o.url !== "/" ? a() : (s.setHeader("Content-Type", "application/json"), s.writeHead(200), s.end(
        JSON.stringify({
          url: `http://localhost:${this.port}/${this.entryFilePath}`,
          entryFilePath: this.entryFilePath,
          port: this.port,
          version: x.version
        })
      ))), (await e.listen(this.port, !0)).printUrls();
    } catch (e) {
      console.error(e), process.exit(1);
    }
  }
}
const O = async (t, e, r) => {
  n.info("Starting the development server..."), await new Re(t, e, r).serve();
}, p = A(x.name.split("/")[1]);
p.command("login [instanceUrl]", "log in to a Frontify instance").option("-i, --instance [instanceUrl]", "[string] url of the Frontify instance").option("-p, --port <port>", "[number] port for the oauth service", {
  default: process.env.PORT || 5600
}).action(async (t, e) => {
  const r = t || e.instance || process.env.INSTANCE_URL;
  r && w.inject([r]);
  const { promptedInstanceUrl: o } = await w([
    {
      type: "text",
      name: "promptedInstanceUrl",
      message: "Enter a Frontify instance URL",
      initial: "instanceName.frontify.com",
      validate: (a) => a.trim() === "" ? "You need to enter a valid URL." : !0
    }
  ]);
  o || E(0);
  const s = P(o);
  await ve(s, e.port);
});
p.command("logout", "log out of an instance").action(be);
for (const t of ["block", "theme"])
  p.command(`${t} serve`, `[deprecated: use 'serve' instead] serve the ${t} locally`).alias(`${t} dev`).option("-e, --entryPath, --entry-path <entryPath>", `[string] path to the ${t} entry file`, {
    default: l("src", "index.tsx")
  }).option("--port <port>", "[number] specify port", {
    default: process.env.PORT || 5600
  }).option("--allowExternal, --allow-external", "[boolean] allow external IPs to access the server", {
    default: !1
  }).action(async (e) => {
    await O(e.entryPath, e.port, e.allowExternal);
  });
p.command("serve", "serve the app locally").alias("dev").option("-e, --entryPath, --entry-path <entryPath>", "[string] path to the entry file", {
  default: l("src", "index.ts")
}).option("--port <port>", "[number] specify port", {
  default: process.env.PORT || 5600
}).option("--allowExternal, --allow-external", "[boolean] allow external IPs to access the server", {
  default: !1
}).action(async (t) => {
  await O(t.entryPath, t.port, t.allowExternal);
});
for (const t of ["block", "theme"])
  p.command(`${t} deploy`, `[deprecated: use 'deploy' instead] deploy the ${t} to the marketplace`).option("-e, --entryPath <entryPath>", "[string] path to the entry file", { default: l("src", "index.tsx") }).option("-o, --outDir <outDir>", "[string] path to the output directory", { default: "dist" }).option("--dryRun, --dry-run", "[boolean] enable the dry run mode", { default: !1 }).option("--noVerify, --no-verify", "[boolean] disable the linting and typechecking", { default: !1 }).option("--open", "[boolean] open the marketplace app page", { default: !1 }).action(async (e) => {
    await D(e.entryPath, e.outDir, {
      dryRun: e.dryRun,
      noVerify: e.noVerify,
      openInBrowser: e.open
    });
  });
p.command("deploy", "deploy the app to the marketplace").option("-e, --entryPath <entryPath>", "[string] path to the entry file", { default: l("src", "index.ts") }).option("-o, --outDir <outDir>", "[string] path to the output directory", { default: "dist" }).option("--dryRun, --dry-run", "[boolean] enable the dry run mode", { default: !1 }).option("--noVerify, --no-verify", "[boolean] disable the linting and typechecking", { default: !1 }).option("--open", "[boolean] open the marketplace app page", { default: !1 }).action(async (t) => {
  await D(t.entryPath, t.outDir, {
    dryRun: t.dryRun,
    noVerify: t.noVerify,
    openInBrowser: t.open
  });
});
p.command("create [appName]", "create a new marketplace app").action(async (t) => {
  const { promptedAppName: e, stylingFramework: r } = await w([
    {
      type: "text",
      name: "promptedAppName",
      message: "Enter your app name",
      initial: t || "my-frontify-app",
      validate: (o) => o.trim() === "" ? "You need to enter an app name." : ue(o)
    },
    {
      type: "select",
      name: "stylingFramework",
      message: "Choose a styling framework",
      choices: [
        { title: "Tailwind", value: "tailwind" },
        { title: "CSS Modules", value: "css-modules" },
        { title: "None", value: "css" }
      ]
    }
  ]);
  (!e || !r) && E(0), _(e, r);
});
for (const t of ["block", "theme"])
  p.command(
    `${t} create [appName]`,
    `[deprecated: use 'create' instead] create a ${t} app locally`
  ).action((e) => _(e, "css-modules"));
p.help();
p.version(x.version);
const _e = (t) => {
  const e = t.findIndex((r) => r === "block" || r === "theme");
  return e !== -1 && (t[e + 1] === "serve" || t[e + 1] === "deploy" || t[e + 1] === "create") && (t[e] = `${t[e]} ${t[e + 1]}`, t.splice(e + 1, 1)), t;
};
p.parse(_e(process.argv));
//# sourceMappingURL=index.mjs.map
