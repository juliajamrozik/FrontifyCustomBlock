import { useState as l, useCallback as g, useEffect as w } from "react";
import { produce as D } from "immer";
const f = (o, t) => o.sort && t.sort ? o.sort - t.sort : 0, P = (o, t = { enabled: !0 }) => {
  const [e, r] = l(/* @__PURE__ */ new Map([])), [m, d] = l(!0), u = g(async () => {
    d(!0), r(await M(o)), d(!1);
  }, [o]);
  return w(() => {
    t.enabled && u();
  }, [t.enabled, u]), w(() => {
    const i = (n) => {
      r(
        D((a) => {
          const A = `${n.action}-document`;
          return (G[A] || G.default)(a, n.document);
        })
      );
    }, c = (n) => {
      ((n == null ? void 0 : n.action) === "move" || (n == null ? void 0 : n.action) === "add") && e.size > 0 && u();
    }, s = (n) => {
      r(
        D((a) => v(a, n.document, n.position, n.newGroupId))
      );
    }, p = (n) => {
      r(
        D((a) => h(a, n.documentGroup, n.position))
      );
    };
    return window.emitter.on("AppBridge:GuidelineDocumentGroup:Action", u), window.emitter.on("AppBridge:GuidelineDocumentGroup:DocumentAction", i), window.emitter.on("AppBridge:GuidelineDocument:Action", c), window.emitter.on("AppBridge:GuidelineDocument:MoveEvent", s), window.emitter.on("AppBridge:GuidelineDocumentGroup:MoveEvent", p), () => {
      window.emitter.off("AppBridge:GuidelineDocumentGroup:Action", u), window.emitter.off("AppBridge:GuidelineDocumentGroup:DocumentAction", i), window.emitter.off("AppBridge:GuidelineDocument:Action", c), window.emitter.off("AppBridge:GuidelineDocument:MoveEvent", s), window.emitter.off("AppBridge:GuidelineDocumentGroup:MoveEvent", p);
    };
  }, [e.size, u]), { documentGroups: Array.from(e.values()), refetch: u, isLoading: m };
}, v = (o, t, e, r) => {
  if (r || !t.sort)
    return o;
  const m = t.sort, d = [...o.values()].sort(f), u = [];
  o.clear();
  for (const c of d) {
    const s = c.sort ?? 0;
    let p = 0;
    e < s ? p = m > s || m === 0 ? 1 : 0 : p = m <= s ? -1 : 0, u.push({
      ...c,
      sort: s + p
    });
  }
  const i = [...u].sort(f);
  for (const c of i)
    o.set(c.id, c);
  return o;
}, h = (o, t, e) => {
  if (!t.sort)
    return o;
  const r = t.sort, m = [...o.values()].sort(f), d = [];
  o.clear();
  for (const i of m) {
    if (i.id === t.id) {
      d.push({ ...i, sort: e });
      continue;
    }
    const c = i.sort ?? 0;
    let s = 0;
    e <= c && (s = r > c ? 1 : 0), d.push({
      ...i,
      sort: c + s
    });
  }
  const u = [...d].sort(f);
  for (const i of u)
    o.set(i.id, i);
  return o;
}, B = (o, t) => {
  if (!t.documentGroupId)
    return o;
  const e = o.get(t.documentGroupId);
  if (!e)
    return o;
  const r = {
    ...e,
    numberOfDocuments: e.numberOfDocuments + 1
  };
  return o.set(e.id, r);
}, E = (o, t) => {
  if (!t.documentGroupId)
    return o;
  const e = o.get(t.documentGroupId);
  if (!e)
    return o;
  const r = {
    ...e,
    numberOfDocuments: e.numberOfDocuments - 1
  };
  return o.set(e.id, r);
}, G = {
  "add-document": B,
  "delete-document": E,
  default: (o) => o
}, M = async (o) => {
  const t = await o.getDocumentGroups();
  return new Map([...t].sort(f).map((e) => [e.id, e]));
};
export {
  P as useDocumentGroups
};
//# sourceMappingURL=useDocumentGroups.es.js.map
