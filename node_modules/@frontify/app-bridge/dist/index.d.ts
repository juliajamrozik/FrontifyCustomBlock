import { CamelCasedPropertiesDeep } from 'type-fest';
import { ComponentType } from 'react';
import { Merge } from 'type-fest';
import type { RequireAtLeastOne } from 'type-fest';
import type { SetOptional } from 'type-fest';
import type { SetRequired } from 'type-fest';
import { Simplify } from 'type-fest';
import { SinonStubbedInstance } from 'sinon';
import { SnakeCasedPropertiesDeep } from 'type-fest';
import { ValueOf } from 'type-fest';

declare type ApiHandler<ApiMethodName extends keyof ApiMethodNamePattern, ApiMethod extends ApiMethodNamePattern> = ApiMethod[ApiMethodName]['payload'] extends void ? {
    name: ApiMethodName;
} : {
    name: ApiMethodName;
    payload: ApiMethod[ApiMethodName]['payload'];
};

export declare type ApiHandlerParameter<ApiMethodName, ApiMethod extends ApiMethodNamePattern> = ApiMethodName extends keyof ApiMethodNamePattern ? ApiHandler<ApiMethodName, ApiMethod> : WrongNamePattern<ApiMethodName, 'API Method'>;

declare type ApiMethodNamePattern = {
    [apiMethod: `${ApiVerb}${string}`]: {
        payload: unknown;
        response: unknown;
    };
};

export declare type ApiMethodNameValidator<ApiMethodNameObject> = Simplify<ObjectNameValidator<ApiMethodNameObject, ApiMethodNamePattern, 'API Method'>>;

export declare type ApiMethodRegistry = ApiMethodNameValidator<{
    getCurrentUser: {
        payload: GetCurrentUserPayload;
        response: GetCurrentUserResponse;
    };
}>;

export declare type ApiReturn<ApiMethodName extends keyof ApiMethod, ApiMethod extends ApiMethodNamePattern> = ApiMethodName extends keyof ApiMethod ? ApiMethod[ApiMethodName] extends {
    response: infer Response;
} ? Promise<Response> : never : never;

export declare type ApiVerb = 'get' | 'create' | 'update' | 'delete' | 'add' | 'remove' | 'set';

export declare interface AppBridge<ApiMethod extends ApiMethodNamePattern, Command extends CommandNamePattern, State extends Record<string, Record<string, unknown>>, Context extends Record<string, unknown>, Event extends EventNamePattern> {
    /**
     * Makes a request to the Frontify platform with the given API method name
     */
    api<ApiMethodName extends keyof ApiMethod>(apiHandler: ApiHandlerParameter<ApiMethodName, ApiMethod>): ApiReturn<ApiMethodName, ApiMethod>;
    /**
     * Sends a command to the Frontify platform.
     *
     * @returns A promise that resolves to acknowledge the dispatch.
     * The event will be triggered at a later stage and can be subscribed to with {@link AppBridgePlatformApp.subscribe}.
     */
    dispatch<CommandName extends keyof Command>(dispatchHandler: DispatchHandlerParameter<CommandName, Command>): Promise<void>;
    /**
     * Returns a state utility object that can be used to get and set state values.
     *
     * @returns the state utility object.
     */
    state(): StateReturn<State, void>;
    /**
     * Returns a state utility object that can be used to get and set state values.
     *
     * @returns the state utility object focused on the given key is returned.
     */
    state<Key extends keyof State>(key: Key): StateReturn<State, Key>;
    state(key?: keyof State | void): unknown;
    /**
     * Returns a context utility object that can be used to get context values.
     *
     * @returns the context utility object.
     */
    context(): ContextReturn<Context, void>;
    /**
     * Returns a context utility object that can be used to get context values.
     *
     * @returns the context utility object focused on the given key is returned.
     */
    context<Key extends keyof Context>(key: Key): ContextReturn<Context, Key>;
    context(key?: keyof Context | void): unknown;
    /**
     * Subscribes to an event with the given name and callback function.
     * The event are fired from {@link AppBridgePlatformApp.dispatch}, {@link AppBridgePlatformApp.state} and {@link AppBridgePlatformApp.context}.
     *
     * @returns Function that can be used to unsubscribe from an event.
     * When called, this function will remove the subscription to the event and prevent any further callbacks from being executed.
     */
    subscribe<EventName extends keyof Event>(eventName: EventNameParameter<EventName, Event>, callback: EventCallbackParameter<EventName, Event>): EventUnsubscribeFunction;
}

export declare interface AppBridgeBase {
    getProjectId(): number;
    getEditorState(): boolean;
    getTranslationLanguage(): string;
    getColorPalettes(): Promise<ColorPalette[]>;
    getColorsByColorPaletteId(colorPaletteId: number): Promise<Color[]>;
    getAllDocuments(): Promise<Document_2[]>;
    getUngroupedDocuments(): Promise<Document_2[]>;
    getDocumentsByDocumentGroupId(documentGroupId: number): Promise<Document_2[]>;
    getDocumentGroups(): Promise<DocumentGroup[]>;
    getDocumentPagesByDocumentId(documentId: number): Promise<DocumentPage[]>;
    getDocumentPagesByDocumentCategoryId(documentCategoryId: number): Promise<DocumentPage[]>;
    getDocumentCategoriesByDocumentId(documentId: number): Promise<DocumentCategory[]>;
    getUncategorizedDocumentPagesByDocumentId(documentId: number): Promise<DocumentPage[]>;
    getDocumentSectionsByDocumentPageId(documentPageId: number): Promise<DocumentSection[]>;
    getDocumentTargets(documentId: number): Promise<DocumentTargets>;
    getDocumentPageTargets(documentPageId: number): Promise<DocumentPageTargets>;
}

export declare interface AppBridgeBlock<State extends BlockState = BlockState, Context extends BlockContext = BlockContext, Event extends BlockEvent = BlockEvent> extends AppBridge<BlockApiMethod, BlockCommand, State, Context, Event>, AppBridgeBase {
    api<ApiMethodName extends keyof BlockApiMethod>(apiHandler: ApiHandlerParameter<ApiMethodName, BlockApiMethod>): ApiReturn<ApiMethodName, BlockApiMethod>;
    dispatch<CommandName extends keyof BlockCommand>(dispatchHandler: DispatchHandlerParameter<CommandName, BlockCommand>): Promise<void>;
    state(): StateReturn<State, void>;
    state<Key extends keyof State>(key: Key): StateReturn<State, Key>;
    state(key?: keyof State | void): unknown;
    context(): ContextReturn<Context, void>;
    context<Key extends keyof Context>(key: Key): ContextReturn<Context, Key>;
    context(key?: keyof Context | void): unknown;
    subscribe<EventName extends keyof Event>(eventName: EventNameParameter<EventName, Event>, callback: EventCallbackParameter<EventName, Event>): EventUnsubscribeFunction;
    getBlockId(): number;
    getSectionId(): number | undefined;
    getBlockAssets(): Promise<Record<string, Asset[]>>;
    getAssetById(assetId: number): Promise<Asset>;
    deleteAssetIdsFromBlockAssetKey(key: string, assetIds: number[]): Promise<void>;
    addAssetIdsToBlockAssetKey(key: string, assetIds: number[]): Promise<void>;
    /**
     * @deprecated This will be removed in version 4.0.0 of @frontify/app-bridge
     * Use appBridge.dispatch(openAssetViewer(token)) instead
     */
    openAssetViewer(token: string): void;
    getBlockTemplates(): Promise<Record<string, Template[]>>;
    addTemplateIdsToBlockTemplateKey(key: string, templateIds: number[]): Promise<Record<string, Template[]>>;
    deleteTemplateIdsFromBlockTemplateKey(key: string, templateIds: number[]): Promise<void>;
    getTemplateById(templateId: number): Promise<TemplateLegacy>;
    getColorsByIds(colorIds: number[]): Promise<Color[]>;
    getColors(): Promise<Color[]>;
    /**
     * @deprecated Use `getColors` instead.
     */
    getAvailableColors(): Promise<Color[]>;
    /**
     * @deprecated Use `getColorPalettes` instead.
     */
    getAvailablePalettes(): Promise<ColorPalette[]>;
    getColorPalettesWithColors(colorPaletteIds?: number[]): Promise<ColorPalette[]>;
    createColorPalette(colorPaletteCreate: ColorPaletteCreate): Promise<ColorPalette>;
    updateColorPalette(colorPaletteId: number, colorPalettePatch: ColorPalettePatch): Promise<ColorPalette>;
    deleteColorPalette(colorPaletteId: number): Promise<void>;
    createColor(colorCreate: ColorCreate): Promise<Color>;
    updateColor(colorId: number, colorPatch: ColorPatch): Promise<Color>;
    deleteColor(colorId: number): Promise<void>;
    downloadColorKit(selectedColorPalettes: number[]): string;
    getBlockSettings<T = Record<string, unknown>>(): Promise<T>;
    updateBlockSettings<T = Record<string, unknown>>(newSettings: T): Promise<void>;
    /**
     * @deprecated This will be removed in version 4.0.0 of @frontify/app-bridge
     * Use appBridge.dispatch(openTemplateChooser()) instead
     */
    openTemplateChooser(callback: (selectedTemplate: TemplateLegacy) => void): void;
    /**
     * @deprecated This will be removed in version 4.0.0 of @frontify/app-bridge
     * Use appBridge.dispatch(closeTemplateChooser()) instead
     */
    closeTemplateChooser(): void;
    getCurrentLoggedUser(): Promise<User>;
    getBulkDownloadToken(assetIds: number[], setIds?: number[]): Promise<string>;
    getBulkDownloadByToken(token: string): Promise<BulkDownload>;
    getBulkDownloadBySignature(signature: string): Promise<BulkDownload>;
    getPrivacySettings(): PrivacySettings;
    /**
     * @deprecated This will be removed in version 4.0.0 of @frontify/app-bridge
     * Use appBridge.dispatch(openAssetChooser(options)) to open the asset chooser
     * and appBridge.subscribe('assetsChosen', callback) to subscribe to the asset chosen event
     */
    openAssetChooser(callback: (selectedAssets: Asset[]) => void, options?: AssetChooserOptions): void;
    /**
     * @deprecated This will be removed in version 4.0.0 of @frontify/app-bridge
     * Use appBridge.dispatch(closeAssetChooser()) instead
     */
    closeAssetChooser(): void;
}

export declare class AppBridgeCreateAsset {
    getAppState<T = Record<string, unknown>>(): Promise<T>;
    putAppState(newState: NotifyData): Promise<boolean>;
    deleteAppState(): Promise<boolean>;
    getAssetById(assetId: number): Promise<AssetApi>;
    postExternalAssets(assets: PostExternalAssetParams[]): Promise<AssetApi[]>;
    getThirdPartyOauth2Tokens(): Promise<OauthTokens>;
    getRefreshedThirdpartyOauth2Tokens(refreshToken: string): Promise<OauthTokens>;
    closeApp(): void;
    openAssetChooser(): void;
}

export declare interface AppBridgePlatformApp<State extends PlatformAppState = PlatformAppState, Context extends PlatformAppContext = PlatformAppContext, Event extends PlatformAppEvent = PlatformAppEvent> extends AppBridge<PlatformAppApiMethod, PlatformAppCommand, State, Context, Event> {
    api<ApiMethodName extends keyof PlatformAppApiMethod>(apiHandler: ApiHandlerParameter<ApiMethodName, PlatformAppApiMethod>): ApiReturn<ApiMethodName, PlatformAppApiMethod>;
    dispatch<CommandName extends keyof PlatformAppCommand>(dispatchHandler: DispatchHandlerParameter<CommandName, PlatformAppCommand>): Promise<void>;
    state(): StateReturn<State, void>;
    state<Key extends keyof State>(key: Key): StateReturn<State, Key>;
    state(key?: keyof State | void): unknown;
    context(): ContextReturn<Context, void>;
    context<Key extends keyof Context>(key: Key): ContextReturn<Context, Key>;
    context(key?: keyof Context | void): unknown;
    subscribe<EventName extends keyof Event>(eventName: EventNameParameter<EventName, Event>, callback: EventCallbackParameter<EventName, Event>): EventUnsubscribeFunction;
}

export declare interface AppBridgeTheme<State extends ThemeState = ThemeState, Context extends ThemeContext = ThemeContext, Event extends ThemeEvent = ThemeEvent> extends AppBridge<ThemeApiMethod, ThemeCommand, State, Context, Event>, AppBridgeBase {
    api<ApiMethodName extends keyof ThemeApiMethod>(apiHandler: ApiHandlerParameter<ApiMethodName, ThemeApiMethod>): ApiReturn<ApiMethodName, ThemeApiMethod>;
    dispatch<CommandName extends keyof ThemeCommand>(dispatchHandler: DispatchHandlerParameter<CommandName, ThemeCommand>): Promise<void>;
    state(): StateReturn<State, void>;
    state<Key extends keyof State>(key: Key): StateReturn<State, Key>;
    state(key?: keyof State | void): unknown;
    context(): ContextReturn<Context, void>;
    context<Key extends keyof Context>(key: Key): ContextReturn<Context, Key>;
    context(key?: keyof Context | void): unknown;
    subscribe<EventName extends keyof Event>(eventName: EventNameParameter<EventName, Event>, callback: EventCallbackParameter<EventName, Event>): EventUnsubscribeFunction;
    getPortalId(): number;
    getBrandId(): number;
    /**
     * @deprecated This will be removed in version 4.0.0 of @frontify/app-bridge
     * Use appBridge.dispatch(openNavigationManager()) for opening the Navigation Manager
     */
    openNavigationManager(): void;
    getCoverPageTemplateSettings<Settings>(): Promise<Settings>;
    updateCoverPageTemplateSettings(settings: Record<string, unknown>): Promise<void>;
    getThemeSettings<ThemeSettings>(): Promise<ThemeSettings>;
    updateThemeSettings<ThemeSettings extends Record<string, unknown>>(settings: ThemeSettings): Promise<ThemeSettings>;
    getDocumentPageTemplateSettings<Settings>(documentPageId: number): Promise<Settings>;
    updateDocumentPageTemplateSettings(documentPageId: number, settings: Record<string, unknown>): Promise<void>;
    addAssetIdsToCoverPageTemplateAssetKey(key: string, assetIds: number[]): Promise<Record<string, Asset[]>>;
    getCoverPageTemplateAssets(): Promise<Record<string, Asset[]>>;
    deleteAssetIdsFromCoverPageTemplateAssetKey(key: string, assetIds: number[]): Promise<void>;
    addAssetIdsToThemeAssetKey(key: string, assetIds: number[]): Promise<Record<string, Asset[]>>;
    getThemeAssets(): Promise<Record<string, Asset[]>>;
    deleteAssetIdsFromThemeAssetKey(key: string, assetIds: number[]): Promise<void>;
    addAssetIdsToLibraryPageTemplateAssetKey(documentId: number, key: string, assetIds: number[]): Promise<Record<string, Asset[]>>;
    getLibraryPageTemplateAssets(documentId: number): Promise<Record<string, Asset[]>>;
    deleteAssetIdsFromLibraryPageTemplateAssetKey(documentId: number, key: string, assetIds: number[]): Promise<void>;
    addAssetIdsToDocumentPageTemplateAssetKey(documentPageId: number, key: string, assetIds: number[]): Promise<Record<string, Asset[]>>;
    getDocumentPageTemplateAssets(documentPageId: number): Promise<Record<string, Asset[]>>;
    deleteAssetIdsFromDocumentPageTemplateAssetKey(documentPageId: number, key: string, assetIds: number[]): Promise<void>;
    getLibraryPageTemplateSettings<Settings>(documentId: number): Promise<Settings>;
    updateLibraryPageTemplateSettings(documentId: number, settings: Record<string, unknown>): Promise<void>;
    createLink(link: DocumentLinkCreate): Promise<Document_2>;
    updateLink(link: DocumentLinkUpdate): Promise<Document_2>;
    deleteLink(documentId: number): Promise<void>;
    createLibrary(library: DocumentLibraryCreate): Promise<Document_2>;
    updateLibrary(library: DocumentLibraryUpdate): Promise<Document_2>;
    deleteLibrary(documentId: number): Promise<void>;
    createStandardDocument(document: DocumentStandardCreate): Promise<Document_2>;
    updateStandardDocument(document: DocumentStandardUpdate): Promise<Document_2>;
    deleteStandardDocument(id: number): Promise<void>;
    moveDocument(documentId: number, position: number, newDocumentGroupId?: number): Promise<Document_2>;
    createDocumentGroup(documentGroup: DocumentGroupCreate): Promise<DocumentGroup>;
    updateDocumentGroup(documentGroup: DocumentGroupUpdate): Promise<DocumentGroup>;
    deleteDocumentGroup(documentGroupId: number): Promise<void>;
    moveDocumentGroup(documentGroupId: number, position: number): Promise<DocumentGroup>;
    createDocumentCategory(category: DocumentCategoryCreate): Promise<DocumentCategory>;
    updateDocumentCategory(category: DocumentCategoryUpdate): Promise<DocumentCategory>;
    deleteDocumentCategory(documentCategoryId: number): Promise<void>;
    moveDocumentCategory(documentCategoryId: number, documentId: number, position: number): Promise<void>;
    createDocumentPage(documentPage: DocumentPageCreate): Promise<DocumentPage>;
    /**
     * A method for page update
     *
     * @param documentPage - {@link DocumentPageUpdate} object
     * @requires id - Indicates page identifier.
     *
     *
     * and at least one of
     *
     * @property  title - Indicates title of a page.
     * @property  documentId - Indicates to witch document the page belongs to.
     * @property  categoryId - Indicates to witch category the page belongs to.
     * @property  visibility - Indicates whether the page is visible only to the editor or everyone.
     * @property  linkUrl - Indicates whether the page is link or not.
     */
    updateDocumentPage(documentPage: DocumentPageUpdate): Promise<DocumentPage>;
    deleteDocumentPage(documentPageId: number): Promise<void>;
    moveDocumentPage(documentPageId: number, documentId: number, position?: number, documentCategoryId?: number): Promise<DocumentPage>;
    duplicateDocumentPage(documentPageId: number): Promise<DocumentPageDuplicate>;
    createCoverPage(coverPage: CoverPageCreate): Promise<CoverPage>;
    updateCoverPage(coverPage: CoverPageUpdate): Promise<CoverPage>;
    /**
     * @deprecated legacy method, should be removed once new endpoint is available
     */
    updateLegacyCoverPage(coverPage: CoverPageUpdateLegacy): Promise<CoverPageUpdateLegacy>;
    deleteCoverPage(): Promise<void>;
    updateBrandportalLink(brandportalLink: Partial<BrandportalLink>): Promise<Partial<BrandportalLink> | null>;
    getCoverPage(): Promise<CoverPage>;
    getBrandportalLink(): Promise<BrandportalLink>;
    getUngroupedDocuments(): Promise<Document_2[]>;
    updateDocumentTargets(targetIds: number[], documentIds: number[]): Promise<TargetsUpdate>;
    updateDocumentPageTargets(targetIds: number[], documentPageIds: number[]): Promise<TargetsUpdate>;
    /**
     * Search in the current Guideline for a given query.
     * @param query - The query to search for.
     * @param order - The order in which the results should be returned. Defaults to 'relevance'.
     */
    searchInGuideline(query: string, order?: 'relevance' | 'newest' | 'oldest'): Promise<GuidelineSearchResult[]>;
    /**
     * @deprecated This will be removed in version 4.0.0 of @frontify/app-bridge
     * Use appBridge.dispatch(openAssetChooser(options)) to open the asset chooser
     * and appBridge.subscribe('assetsChosen', callback) to subscribe to the asset chosen event
     */
    openAssetChooser(callback: (selectedAssets: Asset[]) => void, options?: AssetChooserOptions): void;
    /**
     * @deprecated This will be removed in version 4.0.0 of @frontify/app-bridge
     * Use appBridge.dispatch(closeAssetChooser()) instead
     */
    closeAssetChooser(): void;
}

export declare type Asset = {
    id: number;
    creatorName: string;
    extension: string;
    externalUrl: Nullable<string>;
    fileName: string;
    title: string;
    status: string;
    objectType: string;
    height: Nullable<number>;
    width: Nullable<number>;
    genericUrl: string;
    previewUrl: string;
    originUrl: string;
    projectId: number;
    fileSize: number;
    fileSizeHumanReadable: string;
    fileId: string;
    token: string;
};

export declare type AssetApi = {
    id: number;
    creator_name: string;
    ext: string;
    external_url: Nullable<string>;
    file_name: string;
    title: string;
    status: string;
    object_type: string;
    height: Nullable<number>;
    width: Nullable<number>;
    generic_url: string;
    preview_url: string;
    file_origin_url: string;
    project_id: number;
    file_size: number;
    file_size_formatted: string;
    file_id: string;
    project_name: Nullable<string>;
    project_type: Nullable<string>;
    token: string;
};

export declare class AssetApiDummy {
    static with(id: number): AssetApi;
}

export declare type AssetChooserAssetChosenCallback = (selectedAsset: {
    screenData: AssetChooserResult[];
}) => void;

export declare enum AssetChooserObjectType {
    File = "FILE",
    Canvas = "CANVAS",
    ImageVideo = "IMAGE",
    TextSnippet = "TEXT_SNIPPET",
    Url = "URL"
}

export declare type AssetChooserOptions = {
    projectTypes?: AssetChooserProjectType[];
    objectTypes?: AssetChooserObjectType[];
    multiSelection?: boolean;
    extensions?: (FileExtension | string)[];
    urlContains?: string;
} & ({
    selectedValueId?: number | string;
} | {
    selectedValueIds?: (number | string)[];
});

export declare class AssetChooserOptionsDummy {
    static default(): AssetChooserOptions;
    static withSingleSelectedValue(selectedValueId?: number): AssetChooserOptions;
    static withMultiSelectedValues(selectedValueIds?: number[]): AssetChooserOptions;
}

export declare enum AssetChooserProjectType {
    MediaLibrary = "MediaLibrary",
    LogoLibrary = "LogoLibrary",
    IconLibrary = "IconLibrary",
    DocumentLibrary = "DocumentLibrary",
    TemplateLibrary = "TemplateLibrary",
    PatternLibrary = "PatternLibrary",
    Styleguide = "Styleguide",
    Workspace = "Workspace"
}

export declare type AssetChooserResult = Omit<AssetApi, 'project_id' | 'file_size'> & {
    project: number;
    filesize: number;
};

export declare class AssetChooserResultDummy {
    static with(id: number): AssetChooserResult;
}

export declare class AssetDummy {
    static with(id: number): Asset;
}

export declare type BlockApiMethod = ApiMethodNameValidator<Pick<ApiMethodRegistry, 'getCurrentUser'>>;

export declare type BlockCommand = CommandNameValidator<Pick<CommandRegistry, 'closeAssetChooser' | 'closeTemplateChooser' | 'openAssetChooser' | 'openAssetViewer' | 'openTemplateChooser'>>;

export declare type BlockContext = {
    portalId: number;
    blockId: number;
    sectionId?: number;
};

export declare type BlockEvent = EventNameValidator<Pick<EventRegistry, 'assetsChosen' | 'templateChosen'> & StateAsEventName<BlockState & {
    '*': BlockState;
}> & ContextAsEventName<BlockContext & {
    '*': BlockContext;
}>>;

export declare type BlockSettingsUpdateEvent<T = Record<string, unknown>> = {
    blockId: number;
    blockSettings: T;
};

export declare type BlockState = {
    settings: Record<string, unknown>;
    assets: Record<string, unknown>;
    templates: Record<string, unknown>;
};

export declare type BrandportalLink = BrandportalLinkApi['brand_portal'];

export declare type BrandportalLinkApi = {
    brand_portal: {
        enabled: boolean;
        label: string;
        url: string;
    };
};

export declare class BrandportalLinkApiDummy {
    static get(): BrandportalLinkApi;
}

export declare class BrandportalLinkDummy {
    static with(fields?: Partial<BrandportalLink>): BrandportalLink;
}

export declare type BulkDownload = CamelCasedPropertiesDeep<BulkDownloadApi>;

export declare type BulkDownloadApi = {
    download_url: string;
    signature: string;
};

export declare class BulkDownloadDummy {
    static default(): BulkDownload;
}

export declare enum BulkDownloadState {
    Init = "init",
    Started = "started",
    Pending = "pending",
    Ready = "ready",
    Error = "error"
}

export declare const closeAssetChooser: () => DispatchHandlerParameter<'closeAssetChooser', CommandRegistry>;

declare type CloseAssetChooserPayload = void;

declare type CloseTemplateChooser = void;

export declare const closeTemplateChooser: () => DispatchHandlerParameter<'closeTemplateChooser', CommandRegistry>;

export declare type Color = {
    id: number;
    name: Nullable<string>;
    sort: number;
    nameCss: Nullable<string>;
    hex: Nullable<string>;
    red: Nullable<number>;
    green: Nullable<number>;
    blue: Nullable<number>;
    alpha: Nullable<number>;
    hue: number;
    saturation: number;
    lightness: Nullable<number>;
    c: Nullable<number>;
    m: Nullable<number>;
    y: Nullable<number>;
    k: Nullable<number>;
    pantone: Nullable<string>;
    ral: Nullable<string>;
    oracal: Nullable<string>;
    pantoneCoated: Nullable<string>;
    pantoneUncoated: Nullable<string>;
    cmykCoated: Nullable<string>;
    cmykUncoated: Nullable<string>;
    cmykNewspaper: Nullable<string>;
    ncs: Nullable<string>;
    pantoneCp: Nullable<string>;
    pantonePlastics: Nullable<string>;
    pantoneTextile: Nullable<string>;
    hks: Nullable<string>;
    threeM: Nullable<string>;
    lab: Nullable<string>;
};

export declare type ColorApi = {
    id: number;
    creator: number;
    created: string;
    modifier: Nullable<number>;
    modified: Nullable<string>;
    valid_from: Nullable<string>;
    valid_to: Nullable<string>;
    project: number;
    reference_color: Nullable<number>;
    group: Nullable<string>;
    palette: Nullable<number>;
    type: Nullable<string>;
    name: Nullable<string>;
    name_css: Nullable<string>;
    sort: number;
    hex: Nullable<string>;
    r: Nullable<number>;
    g: Nullable<number>;
    b: Nullable<number>;
    alpha: Nullable<number>;
    hue: number;
    saturation: number;
    lightness: Nullable<number>;
    gradient_direction: Nullable<string>;
    gradient_color_one: Nullable<number>;
    gradient_color_two: Nullable<number>;
    gradient_type: Nullable<string>;
    usage: string;
    priority: Nullable<number>;
    c: Nullable<number>;
    m: Nullable<number>;
    y: Nullable<number>;
    k: Nullable<number>;
    pantone: Nullable<string>;
    ral: Nullable<string>;
    oracal: Nullable<string>;
    pantone_coated: Nullable<string>;
    pantone_uncoated: Nullable<string>;
    cmyk_coated: Nullable<string>;
    cmyk_uncoated: Nullable<string>;
    cmyk_newspaper: Nullable<string>;
    ncs: Nullable<string>;
    pantone_cp: Nullable<string>;
    pantone_plastics: Nullable<string>;
    pantone_textile: Nullable<string>;
    hks: Nullable<string>;
    three_m: Nullable<string>;
    lab: Nullable<string>;
    opacity: Nullable<number>;
    opacity_css: Nullable<number>;
    css_value: Nullable<string>;
};

export declare type ColorApiCreate = {
    project_color_palette_id: number;
    red: number;
    green: number;
    blue: number;
    alpha: number;
};

export declare class ColorApiCreateDummy {
    static red(): ColorApiCreate;
}

export declare class ColorApiDummy {
    static red(id?: number): ColorApi;
    static yellow(id?: number): ColorApi;
    static green(id?: number): ColorApi;
}

export declare type ColorApiPatch = Partial<{
    language: Nullable<string>;
    name: Nullable<string>;
    name_css: Nullable<string>;
    sort: Nullable<number>;
    red: Nullable<number>;
    green: Nullable<number>;
    blue: Nullable<number>;
    alpha: Nullable<number>;
    c: Nullable<number>;
    m: Nullable<number>;
    y: Nullable<number>;
    k: Nullable<number>;
    pantone: Nullable<string>;
    ral: Nullable<string>;
    oracal: Nullable<string>;
    pantone_coated: Nullable<string>;
    pantone_uncoated: Nullable<string>;
    cmyk_coated: Nullable<string>;
    cmyk_uncoated: Nullable<string>;
    cmyk_newspaper: Nullable<string>;
    ncs: Nullable<string>;
    pantone_cp: Nullable<string>;
    pantone_plastics: Nullable<string>;
    pantone_textile: Nullable<string>;
    hks: Nullable<string>;
    three_m: Nullable<string>;
    lab: Nullable<string>;
}>;

export declare class ColorApiPatchDummy {
    static red(): ColorApiPatch;
    static yellow(): ColorApiPatch;
    static green(): ColorApiPatch;
}

export declare type ColorCreate = {
    colorPaletteId: number;
    red: number;
    green: number;
    blue: number;
    alpha: number;
};

export declare class ColorCreateDummy {
    static red(): ColorCreate;
}

export declare class ColorDummy {
    static red(id?: number): Color;
    static yellow(id?: number): Color;
    static green(id?: number): Color;
}

export declare type ColorPalette = {
    id: number;
    name: string;
    description: string;
    colors: Color[];
};

export declare type ColorPaletteApi = {
    id: number;
    name: string;
    description: string;
    colors?: Nullable<ColorApi[]>;
};

export declare type ColorPaletteApiCreate = {
    project_id: number;
    name: string;
    description?: string;
};

export declare class ColorPaletteApiCreateDummy {
    static with(projectId?: number): ColorPaletteApiCreate;
}

export declare class ColorPaletteApiDummy {
    static with(id: number, name?: string): ColorPaletteApi;
}

export declare type ColorPaletteApiPatch = Partial<Omit<ColorPaletteApi, 'id' | 'colors'> & {
    language: string;
}>;

export declare class ColorPaletteApiPatchDummy {
    static with(): ColorPaletteApiPatch;
}

export declare type ColorPaletteCreate = {
    name: string;
    description?: string;
};

export declare class ColorPaletteCreateDummy {
    static with(name?: string, description?: string): ColorPaletteCreate;
}

export declare class ColorPaletteDummy {
    static with(id: number, name?: string): ColorPalette;
}

export declare type ColorPalettePatch = Partial<Omit<ColorPalette, 'id' | 'colors'>>;

export declare class ColorPalettePatchDummy {
    static with(): ColorPalettePatch;
}

export declare type ColorPatch = Partial<Omit<Color, 'id' | 'hex' | 'hue' | 'saturation' | 'lightness'>>;

export declare class ColorPatchDummy {
    static red(): ColorPatch;
}

declare type CommandNamePattern = {
    [commandName: `${CommandVerb}${string}`]: unknown;
};

export declare type CommandNameValidator<CommandNameObject> = Simplify<ObjectNameValidator<CommandNameObject, CommandNamePattern, 'Command'>>;

export declare type CommandRegistry = CommandNameValidator<{
    openAssetChooser?: OpenAssetChooserPayload;
    closeAssetChooser: CloseAssetChooserPayload;
    openAssetViewer: OpenAssetViewerPayload;
    openTemplateChooser: OpenTemplateChooser;
    closeTemplateChooser: CloseTemplateChooser;
    openNavigationManager: OpenNavigationManager;
}>;

export declare type CommandVerb = 'open' | 'close' | 'navigate';

export declare const compareObjects: (obj1: unknown, obj2: unknown) => boolean;

export declare type ContextAsEventName<Context> = {
    [ContextKey in keyof Context as ContextKey extends string ? `Context.${ContextKey}` : never]: [
    Context[ContextKey],
    Context[ContextKey]
    ];
};

export declare type ContextReturn<Context, Key> = Key extends keyof Context ? {
    /**
     * Gets the current value of the context object at the given key.
     */
    get(): Readonly<Context[Key]>;
    /**
     * Subscribes to changes in the context object at the given key.
     */
    subscribe(callbackFunction: (nextContext: Context[Key], previousContext: Context[Key]) => void): EventUnsubscribeFunction;
} : {
    /**
     * Gets the current value of the context object.
     */
    get(): Readonly<Context>;
    /**
     * Subscribes to changes in the context object.
     */
    subscribe(callbackFunction: (nextContext: Context, previousContext: Context) => void): EventUnsubscribeFunction;
};

/**
 *
 * @param obj object or array of objects
 * @param caseType camel or snake
 * @returns converted object or array of objects
 */
export declare const convertObjectCase: <Obj extends Record<string, any>, Case extends "camel" | "snake">(obj: Obj, caseType: Case) => Case extends "camel" ? CamelCasedPropertiesDeep<Obj> : SnakeCasedPropertiesDeep<Obj>;

export declare type CoverPage = Merge<CamelCasedPropertiesDeep<Simplify<ValueOf<CoverPageApi, 'brandhome'> & Pick<CoverPageApi, 'template' | 'document_id'>>>, {
    draft: boolean;
    enabled: boolean;
}>;

export declare type CoverPageApi = {
    brandhome: {
        id: number;
        url: string;
        draft: 0 | 1;
        title: string;
        enabled: 0 | 1;
        active: boolean;
        hide_in_nav: boolean;
    };
    items?: unknown;
    brand_portal?: unknown;
    document_groups?: unknown;
    navigation_mode?: unknown;
    template: CoverPageTemplate;
    document_id: string;
};

export declare class CoverPageApiDummy {
    static with(id: number, title?: string): CoverPageApi;
}

export declare type CoverPageCreate = PickRequired<Omit<Partial<CoverPage>, 'id'>, 'documentId' | 'template'>;

export declare class CoverPageDummy {
    static with(id: number, title?: string): CoverPage;
    static withLegacy(id: number, title?: string): CoverPageUpdateLegacy;
}

export declare type CoverPageTemplate = 'hub' | 'explorer' | 'story' | 'cover' | 'blank';

export declare type CoverPageUpdate = RequireOnlyOne<CoverPage, 'id'>;

export declare type CoverPageUpdateLegacy = {
    brandhome_draft?: boolean;
    brandhome_title?: string;
    brandhome_hide_in_nav?: boolean;
};

export declare type CrossDocumentMessage<T = Record<string, unknown>> = {
    topic: Topic;
    token: string;
    data?: T;
};

export declare type CrossDocumentMessageResponse<T> = {
    success: boolean;
    topic: Topic;
    token: string;
    data?: T;
};

declare type DefaultHttpResponse = Record<string, unknown>;

export declare type DispatchHandler<DispatchName extends keyof DispatchPayload> = DispatchPayload[DispatchName] extends void ? {
    name: DispatchName;
} : {
    name: DispatchName;
    payload: DispatchPayload[DispatchName];
};

declare type DispatchHandler_2<CommandName extends keyof CommandNamePattern, Command extends CommandNamePattern> = Command[CommandName] extends void ? {
    name: CommandName;
} : {
    name: CommandName;
    payload: Command[CommandName];
};

export declare type DispatchHandlerParameter<CommandName, Command extends CommandNamePattern> = CommandName extends keyof CommandNamePattern ? DispatchHandler_2<CommandName, Command> : WrongNamePattern<CommandName, 'Command'>;

export declare type DispatchPayload = {
    openAssetChooser?: AssetChooserOptions;
    closeAssetChooser: void;
    openAssetViewer: {
        token: string;
    };
    openTemplateChooser: void;
    closeTemplateChooser: void;
    openNavigationManager: void;
};

declare type Document_2 = CamelCasedPropertiesDeep<DocumentApi>;
export { Document_2 as Document }

export declare type DocumentApi = Simplify<{
    id: number;
    creator: number;
    created: string;
    modifier: Nullable<number>;
    modified: Nullable<string>;
    project_id: number;
    document_group_id?: Nullable<number>;
    valid_from: string;
    valid_to: Nullable<string>;
    visibility: Nullable<string>;
    portal_id: Nullable<number>;
    title: string;
    slug: Nullable<string>;
    heading: Nullable<string>;
    subheading: Nullable<string>;
    description: Nullable<string>;
    logo: Nullable<string>;
    sort: number;
    lazy: Nullable<boolean>;
    link_settings: Nullable<DocumentLinkSettingsApi>;
    view_count: Nullable<number>;
    mode: DocumentMode;
    settings: {
        project?: number;
        project_slug?: string;
        facettes?: any[];
    };
    appearance: Nullable<Record<string, any>>;
    logo_file_id: Nullable<string>;
    logo_settings: Nullable<any>;
    background_file_id: Nullable<string>;
    background_settings: Nullable<any>;
    change_processed: Nullable<string>;
    change_processed_by: Nullable<string>;
    change_skipped: Nullable<string>;
    change_skipped_by: Nullable<string>;
    change_comment: Nullable<string>;
    change_comment_by: Nullable<string>;
    change_title: Nullable<string>;
    targets: Nullable<SingleTargetApi['target'][]>;
    token: Nullable<string>;
    permanent_link: string;
    number_of_document_page_categories: number;
    number_of_uncategorized_document_pages: number;
} & (DocumentApiAsLink | DocumentApiAsNoneLink)>;

declare type DocumentApiAsLink = {
    link_type: 'EXTERNAL';
    link_url: string;
};

declare type DocumentApiAsNoneLink = {
    link_type: 'INTERNAL';
    link_url: Nullable<never>;
};

export declare class DocumentApiDummy {
    static with(id: number): DocumentApi;
}

declare type DocumentAsLink = CamelCasedPropertiesDeep<DocumentApiAsLink>;

declare type DocumentAsNoneLink = CamelCasedPropertiesDeep<DocumentApiAsNoneLink>;

export declare type DocumentBlockAsset = {
    id: number;
    creator: number;
    created: string;
    modifier: number;
    modified: string;
    validTo: Nullable<string>;
    documentBlockId: number;
    settingId: string;
    assetId: number;
    asset: Asset;
};

export declare type DocumentBlockAssetApi = Omit<SnakeCasedPropertiesDeep<DocumentBlockAsset>, 'asset'> & {
    asset: AssetApi;
};

export declare type DocumentBlockTemplate = {
    id: number;
    creator: number;
    created: string;
    modifier: number;
    modified: string;
    validTo: Nullable<string>;
    documentBlockId: number;
    settingId: string;
    templateId: number;
    template: Template;
};

export declare type DocumentBlockTemplateApi = Omit<SnakeCasedPropertiesDeep<DocumentBlockTemplate>, 'template'> & {
    template: Template;
};

export declare type DocumentCategory = CamelCasedPropertiesDeep<DocumentCategoryApi>;

export declare type DocumentCategoryApi = {
    id: number;
    document_id: number;
    slug: string;
    title: string;
    sort: number;
    creator: number;
    created: string;
    modifier: Nullable<string>;
    modified: Nullable<string>;
    valid_from: string;
    valid_to: Nullable<string>;
    number_of_document_pages: number;
};

export declare class DocumentCategoryApiDummy {
    static with(id: number, document_pages?: number[]): DocumentCategoryApi;
    static withDocumentIdAndNumberOfDocumentPages(id: number, documentId: number, numberOfDocumentPages: number): DocumentCategoryApi;
}

export declare type DocumentCategoryCreate = Pick<DocumentCategory, 'title' | 'documentId'>;

export declare type DocumentCategoryDelete = Pick<DocumentCategory, 'id' | 'documentId'>;

export declare class DocumentCategoryDummy {
    static with(id: number): DocumentCategory;
    static withDocumentIdAndNumberOfDocumentPages(id: number, documentId: number, numberOfDocumentPages: number): DocumentCategory;
    static withFields(fields: DocumentCategory): DocumentCategory;
}

export declare type DocumentCategoryUpdate = RequireAtLeastOne<Pick<DocumentCategory, DocumentPageRequestFields>, 'title'>;

export declare class DocumentDummy {
    static with(id: number): Document_2;
    static withDocumentGroupId(id: number, documentGroupId: number): Document_2;
    static withFields(fields: Document_2): Document_2;
}

export declare type DocumentGroup = CamelCasedPropertiesDeep<DocumentGroupApi>;

export declare type DocumentGroupApi = {
    id: number;
    name: string;
    sort: Nullable<number>;
    creator: number;
    created: string;
    modified: Nullable<string>;
    modifier: Nullable<number>;
    valid_to: Nullable<string>;
    project_id: number;
    portal_id: number;
    number_of_documents: number;
};

export declare class DocumentGroupApiDummy {
    static with(id: number, numberOfDocuments?: number): DocumentGroupApi;
}

export declare type DocumentGroupCreate = Pick<DocumentGroup, 'name'>;

export declare type DocumentGroupDelete = Pick<DocumentGroup, 'id'>;

export declare class DocumentGroupDummy {
    static with(id: number, numberOfDocuments?: number): DocumentGroup;
    static withFields(fields: DocumentGroup): DocumentGroup;
}

export declare type DocumentGroupUpdate = Pick<DocumentGroup, 'name' | 'id'>;

export declare type DocumentLibrary = Simplify<Document_2 & DocumentAsNoneLink & {
    settings?: {
        project: number;
    };
    mode: DocumentLibraryMode;
}>;

export declare type DocumentLibraryCreate = SetOptional<Omit<DocumentLibraryRequest, 'id'>, 'heading' | 'subheading' | 'settings'>;

export declare type DocumentLibraryDelete = Pick<DocumentLibraryRequest, 'id' | 'documentGroupId'>;

export declare type DocumentLibraryMode = 'MEDIALIBRARY' | 'ICONLIBRARY' | 'LOGOLIBRARY' | 'DOCUMENTLIBRARY' | 'TEMPLATELIBRARY' | 'TEXTLIBRARY' | 'PATTERNLIBRARY' | 'BRANDUPDATELIBRARY';

declare type DocumentLibraryRequest = {
    id: number;
    mode: DocumentLibraryMode;
    settings: {
        project: number;
    };
    title: string;
    heading?: string;
    subheading?: string;
    documentGroupId?: Nullable<number>;
};

export declare type DocumentLibraryUpdate = RequireAtLeastOne<DocumentLibraryRequest, 'documentGroupId' | 'heading' | 'mode' | 'settings' | 'subheading' | 'title'>;

export declare type DocumentLink = Simplify<Document_2 & DocumentAsLink>;

export declare type DocumentLinkCreate = Omit<DocumentLinkRequest, 'id'>;

export declare type DocumentLinkDelete = Pick<DocumentLinkRequest, 'id' | 'documentGroupId'>;

declare type DocumentLinkRequest = {
    id: number;
    title: string;
    linkUrl: string;
    linkSettings: DocumentLinkSettings;
    documentGroupId?: Nullable<number>;
};

export declare type DocumentLinkSettings = CamelCasedPropertiesDeep<DocumentLinkSettingsApi>;

export declare type DocumentLinkSettingsApi = {
    new_tab: boolean;
    display?: LinkSettingsDisplay;
    icon_position?: LinkSettingsIconPosition;
    file_id?: string;
    screen_id?: number;
    icon_url?: string;
    icon_file_name?: string;
};

export declare type DocumentLinkUpdate = RequireAtLeastOne<DocumentLinkRequest, 'title' | 'linkUrl' | 'linkSettings' | 'documentGroupId'>;

export declare type DocumentMode = Simplify<'DEFAULT' | DocumentLibraryMode>;

export declare type DocumentPage = CamelCasedPropertiesDeep<DocumentPageApi>;

export declare type DocumentPageApi = {
    id: number;
    creator: number;
    created: string;
    modifier: Nullable<number>;
    modified: Nullable<string>;
    document_id: number;
    category_id: Nullable<number>;
    parent_id: Nullable<number>;
    valid_from: string;
    valid_to: Nullable<string>;
    title: string;
    slug: string;
    sort: number;
    view_count: number;
    visibility: DocumentPageVisibility;
    change_processed: Nullable<string>;
    change_processed_by: Nullable<number>;
    change_skipped: Nullable<string>;
    change_skipped_by: Nullable<number>;
    change_comment: Nullable<string>;
    change_comment_by: Nullable<number>;
    change_title: Nullable<string>;
    targets: Nullable<SingleTargetApi['target'][]>;
    category?: Nullable<Record<string, unknown>>;
    parent_document?: Nullable<Record<string, unknown>>;
    parent_portal?: Nullable<Record<string, unknown>>;
    translations?: Nullable<Record<string, unknown>>;
    permanent_link: string;
} & (DocumentPageApiAsLink | DocumentPageApiAsNoneLink);

declare type DocumentPageApiAsLink = {
    link_type: 'EXTERNAL';
    link_url: string;
};

declare type DocumentPageApiAsNoneLink = {
    link_type: 'INTERNAL';
    link_url: Nullable<never>;
};

export declare class DocumentPageApiDummy {
    static with(id: number): DocumentPageApi;
    static withFields(fields: Partial<DocumentPageApi> & {
        id: number;
    }): DocumentPageApi;
}

export declare type DocumentPageCreate = Omit<SetRequired<DocumentPageRequest, 'title' | 'documentId'>, 'id'>;

export declare type DocumentPageDelete = Pick<DocumentPageRequest, 'id' | 'documentId' | 'categoryId'>;

export declare class DocumentPageDummy {
    static with(id: number): DocumentPage;
    static withFields(fields: Partial<DocumentPage> & {
        id: number;
    }): DocumentPage;
}

export declare type DocumentPageDuplicate = CamelCasedPropertiesDeep<DocumentPageDuplicateApi['page']>;

export declare type DocumentPageDuplicateApi = {
    page: {
        id: number;
        link_type: LinkType;
        name: string;
        sections: unknown[];
        url: string;
        visibility: DocumentPageVisibility;
    };
};

export declare class DocumentPageDuplicateApiDummy {
    static with(id: number): DocumentPageDuplicateApiDummy;
}

export declare class DocumentPageDuplicateDummy {
    static with(id: number): DocumentPageDuplicate;
}

declare type DocumentPageRequest = {
    id: number;
    title: Nullable<string>;
    documentId: number;
    linkUrl?: Nullable<string>;
    categoryId?: Nullable<number>;
    visibility?: DocumentPageVisibility;
};

declare type DocumentPageRequestFields = 'title' | 'documentId' | 'id';

export declare type DocumentPageTargetEvent = {
    action: 'update';
    payload: {
        targets: number[];
        pageIds: number[];
    };
};

export declare type DocumentPageTargets = CamelCasedPropertiesDeep<DocumentPageTargetsApi>;

export declare type DocumentPageTargetsApi = {
    default: boolean;
    disabled: SingleTargetApi[];
    has_selected_targets: boolean;
    id: number;
    success: boolean;
    targets: SingleTargetApi[];
};

export declare class DocumentPageTargetsApiDummy {
    static with(id: number): DocumentPageTargetsApi;
}

export declare class DocumentPageTargetsDummy {
    static with(id: number): {
        default: boolean;
        disabled: {
            checked: boolean;
            disabled: boolean;
            indeterminate: boolean;
            label: string;
            target: {
                accountId: number;
                assetIds: {}[];
                created: string;
                creator: number;
                description: string;
                groupIds: {}[];
                id: number;
                modified: {};
                modifier: {};
                name: string;
                sort: number;
                totalGroups: {};
                totalLinks: {};
                totalUsers: {};
                userIds: {}[];
            };
            value: number;
        }[];
        hasSelectedTargets: boolean;
        id: number;
        success: boolean;
        targets: {
            checked: boolean;
            disabled: boolean;
            indeterminate: boolean;
            label: string;
            target: {
                accountId: number;
                assetIds: {}[];
                created: string;
                creator: number;
                description: string;
                groupIds: {}[];
                id: number;
                modified: {};
                modifier: {};
                name: string;
                sort: number;
                totalGroups: {};
                totalLinks: {};
                totalUsers: {};
                userIds: {}[];
            };
            value: number;
        }[];
    };
}

export declare type DocumentPageUpdate = RequireAtLeastOne<DocumentPageRequest, 'documentId' | 'categoryId' | 'linkUrl' | 'title' | 'visibility'>;

export declare enum DocumentPageVisibility {
    Everyone = "EVERYONE",
    Editor = "EDITOR"
}

export declare type DocumentSection = {
    id: number;
    title: string;
    slug: string;
    sort: number;
    permanentLink: string;
};

export declare type DocumentSectionApi = {
    id: number;
    document_id: number;
    page_id: number;
    revision: unknown;
    slug: string;
    sort: number;
    title: string;
    creator: number;
    created: string;
    modifier: Nullable<number>;
    modified: Nullable<string>;
    valid_from: string;
    valid_to: Nullable<string>;
    permanent_link: string;
};

export declare class DocumentSectionApiDummy {
    static with(id: number): DocumentSectionApi;
}

export declare class DocumentSectionDummy {
    static with(id: number): DocumentSection;
}

export declare type DocumentStandard = Simplify<Document_2 & DocumentAsNoneLink>;

export declare type DocumentStandardCreate = Omit<DocumentStandardRequest, 'id'>;

export declare type DocumentStandardDelete = Pick<DocumentStandardRequest, 'documentGroupId' | 'id'>;

declare type DocumentStandardRequest = {
    id: number;
    title: string;
    documentGroupId?: Nullable<number>;
};

export declare type DocumentStandardUpdate = RequireAtLeastOne<DocumentStandardRequest, 'documentGroupId' | 'title'>;

export declare type DocumentTargets = CamelCasedPropertiesDeep<DocumentTargetsApi['targets']>;

export declare type DocumentTargetsApi = {
    appearance: unknown;
    background_file_id: unknown;
    background_url: unknown;
    heading: unknown;
    id: number;
    link_type: unknown;
    link_url: Nullable<string>;
    logo_file_id: unknown;
    logo_url: unknown;
    mode: unknown;
    portal_title: string;
    subheading: unknown;
    success: boolean;
    targets: {
        disabled: SingleTargetApi[];
        has_selected_targets: boolean;
        targets: SingleTargetApi[];
    };
    title: string;
};

export declare class DocumentTargetsApiDummy {
    static with(id: number): DocumentTargetsApi;
}

export declare class DocumentTargetsDummy {
    static with(id: number): {
        disabled: {
            checked: boolean;
            disabled: boolean;
            indeterminate: boolean;
            label: string;
            target: {
                accountId: number;
                assetIds: {}[];
                created: string;
                creator: number;
                description: string;
                groupIds: {}[];
                id: number;
                modified: {};
                modifier: {};
                name: string;
                sort: number;
                totalGroups: {};
                totalLinks: {};
                totalUsers: {};
                userIds: {}[];
            };
            value: number;
        }[];
        hasSelectedTargets: boolean;
        targets: {
            checked: boolean;
            disabled: boolean;
            indeterminate: boolean;
            label: string;
            target: {
                accountId: number;
                assetIds: {}[];
                created: string;
                creator: number;
                description: string;
                groupIds: {}[];
                id: number;
                modified: {};
                modifier: {};
                name: string;
                sort: number;
                totalGroups: {};
                totalLinks: {};
                totalUsers: {};
                userIds: {}[];
            };
            value: number;
        }[];
    };
}

export declare type EmitterAction = 'add' | 'update' | 'delete';

export declare type EmitterEvents = {
    'AppBridge:PageTemplateSettingsUpdated': {
        pageTemplateSettings: Record<string, unknown>;
    };
    'AppBridge:ThemeSettingsUpdated': {
        themeSettings: Record<string, unknown>;
    };
    'AppBridge:BlockSettingsUpdated': BlockSettingsUpdateEvent;
    'AppBridge:BlockAssetsUpdated': {
        blockId: number;
        blockAssets: Record<string, Asset[]>;
        prevBlockAssets: Record<string, Asset[]>;
    };
    'AppBridge:TemplateAssetsUpdated': {
        template?: 'documentPage' | 'library' | 'cover';
        documentId?: number;
        documentPageId?: number;
        templateAssets: Record<string, Asset[]>;
        prevTemplateAssets: Record<string, Asset[]>;
    };
    'AppBridge:ThemeAssetsUpdated': {
        portalId: number;
        themeAssets: Record<string, Asset[]>;
        prevThemeAssets: Record<string, Asset[]>;
    };
    'AppBridge:BlockTemplatesUpdated': {
        blockId: number;
        blockTemplates: Record<string, Template[]>;
        prevBlockTemplates: Record<string, Template[]>;
    };
    'AppBridge:ColorsUpdated': {
        blockId: number;
        colors: Color[];
        prevColors: Color[];
    };
    'AppBridge:ColorPalettesUpdated': {
        blockId: number;
        colorPalettes: ColorPalette[];
        prevColorPalettes: ColorPalette[];
    };
    'AppBridge:GuidelineDocument:Action': {
        document: Document_2;
        action: 'add' | 'update' | 'move';
    } | {
        document: {
            id: number;
            documentGroupId?: Nullable<number>;
        };
        action: 'delete';
    };
    'AppBridge:GuidelineDocumentGroup:Action': {
        documentGroup: DocumentGroup;
        action: 'add' | 'update';
    } | {
        documentGroup: {
            id: number;
        };
        action: 'delete';
    };
    'AppBridge:GuidelineCoverPage:Action': {
        coverPage: CoverPage;
        action: 'add' | 'update';
    } | {
        action: 'delete';
    };
    'AppBridge:GuidelineBrandportalLink:Action': {
        brandportalLink: BrandportalLink;
        action: 'update';
    };
    'AppBridge:PrivacySettingsChanged': PrivacySettings;
    'AppBridge:OpenNavigationManager': void;
    'AppBridge:GuidelineDocumentPage:Action': {
        documentPage: DocumentPage;
        action: 'add' | 'update' | 'move';
    } | {
        documentPage: {
            id: number;
            documentId: number;
            categoryId?: Nullable<number>;
        };
        action: 'delete';
    };
    'AppBridge:GuidelineDocumentCategory:Action': {
        documentCategory: DocumentCategory;
        action: 'add' | 'update';
    } | {
        documentCategory: {
            id: number;
            documentId: number;
        };
        action: 'delete';
    };
    'AppBridge:GuidelineDocumentCategory:DocumentPageAction': {
        documentPage: {
            id: number;
            categoryId: number;
        };
        action: 'add' | 'delete';
    };
    'AppBridge:GuidelineDocument:DocumentPageAction': {
        documentPage: {
            id: number;
            documentId: number;
        };
        action: 'add' | 'delete';
    };
    'AppBridge:GuidelineDocument:DocumentCategoryAction': {
        documentCategory: {
            id: number;
            documentId: number;
        };
        action: 'add' | 'delete';
    };
    'AppBridge:GuidelineDocumentGroup:DocumentAction': {
        document: {
            id: number;
            documentGroupId: number;
        };
        action: 'add' | 'delete';
    };
    'AppBridge:GuidelineDocumentPageTargets:Action': {
        action: 'update';
        payload: {
            targets: number[];
            pageIds: number[];
        };
    };
    'AppBridge:GuidelineDocumentTargets:Action': {
        payload: {
            targets: number[];
            documentIds: number[];
        };
        action: 'update';
    };
    'AppBridge:ViewerOpened': {
        token: string;
    };
    'AppBridge:GuidelineDocumentPage:MoveEvent': {
        documentPage: DocumentPage | {
            id: number;
            sort?: Nullable<number>;
        };
        documentId: number;
        categoryId?: Nullable<number>;
        position?: number;
        action: 'movePreview';
    };
    'AppBridge:GuidelineDocumentCategory:MoveEvent': {
        documentCategory: DocumentCategory | {
            id: number;
            sort?: Nullable<number>;
        };
        documentId: number;
        position: number;
        action: 'movePreview';
    };
    'AppBridge:GuidelineDocument:MoveEvent': {
        document: Document_2 | {
            id: number;
            sort?: Nullable<number>;
            documentGroupId?: Nullable<number>;
        };
        position: number;
        newGroupId?: Nullable<number>;
        action: 'movePreview';
    };
    'AppBridge:GuidelineDocumentGroup:MoveEvent': {
        documentGroup: DocumentGroup | {
            id: number;
            sort?: Nullable<number>;
        };
        position: number;
        action: 'movePreview';
    };
};

declare type EndpointResponse<T> = {
    currentPage?: number;
    totalPages?: number;
    data: T;
    success: boolean;
};

export declare type EventCallbackParameter<EventName, Event> = EventName extends keyof Event ? Event[EventName] extends any[] ? (...eventReturn: Event[EventName]) => void : (eventReturn: Event[EventName]) => void : () => void;

export declare type EventNameParameter<EventName, EventNameParameter extends EventNamePattern> = EventName extends keyof EventNameParameter ? EventName : WrongNamePattern<EventName, 'Event'>;

export declare type EventNamePattern = {
    [eventName: `State.${string}` | `Context.${string}` | `${string}${Capitalize<EventVerb>}`]: unknown;
};

export declare type EventNameValidator<EventNameObject> = Simplify<ObjectNameValidator<EventNameObject, EventNamePattern, 'Event'>>;

export declare type EventRegistry = EventNameValidator<{
    assetsChosen: {
        assets: Asset[];
    };
    templateChosen: {
        template: TemplateLegacy;
    };
}>;

export declare type EventUnsubscribeFunction = () => void;

export declare type EventVerb = 'chosen';

export declare class FetchError extends Error {
    constructor(topic: string);
}

export declare type FileApi = {
    file_id: string;
    file_name: string;
    generic_url: string;
};

export declare enum FileExtension {
    Aac = "aac",
    Ac3 = "ac3",
    Ai = "ai",
    Aif = "aif",
    Aifc = "aifc",
    Aiff = "aiff",
    Artboard = "artboard",
    Asc = "asc",
    Atom = "atom",
    Au = "au",
    Avi = "avi",
    Bcpio = "bcpio",
    Bin = "bin",
    Bmp = "bmp",
    Cdf = "cdf",
    Cgm = "cgm",
    Class = "class",
    Cpio = "cpio",
    Cpt = "cpt",
    Csh = "csh",
    Css = "css",
    Dcr = "dcr",
    Dif = "dif",
    Dir = "dir",
    Djv = "djv",
    Djvu = "djvu",
    Dll = "dll",
    Dmg = "dmg",
    Dms = "dms",
    Dng = "dng",
    Doc = "doc",
    Docx = "docx",
    Dotx = "dotx",
    Docm = "docm",
    Dotm = "dotm",
    Dtd = "dtd",
    Dv = "dv",
    Dvi = "dvi",
    Dxr = "dxr",
    Eps = "eps",
    Etx = "etx",
    Exe = "exe",
    Ez = "ez",
    Flac = "flac",
    Flv = "flv",
    Gif = "gif",
    Gram = "gram",
    Grxml = "grxml",
    Gtar = "gtar",
    Hdf = "hdf",
    Heif = "heif",
    Hqx = "hqx",
    Htm = "htm",
    Html = "html",
    Ice = "ice",
    Ico = "ico",
    Ics = "ics",
    Idml = "idml",
    Ief = "ief",
    Ifb = "ifb",
    Iges = "iges",
    Igs = "igs",
    Indd = "indd",
    Indt = "indt",
    Jnlp = "jnlp",
    Jp2 = "jp2",
    Jpe = "jpe",
    Jpeg = "jpeg",
    Jpg = "jpg",
    Js = "js",
    Kar = "kar",
    Latex = "latex",
    Lha = "lha",
    Lzh = "lzh",
    M3u = "m3u",
    M4a = "m4a",
    M4b = "m4b",
    M4p = "m4p",
    M4r = "m4r",
    M4u = "m4u",
    M4v = "m4v",
    Mac = "mac",
    Man = "man",
    Mathml = "mathml",
    Me = "me",
    Mesh = "mesh",
    Mid = "mid",
    Midi = "midi",
    Mif = "mif",
    Mkv = "mkv",
    Mov = "mov",
    Movie = "movie",
    Mp2 = "mp2",
    Mp3 = "mp3",
    Mp4 = "mp4",
    Mpe = "mpe",
    Mpeg = "mpeg",
    Mpg = "mpg",
    Mpga = "mpga",
    Ms = "ms",
    Msh = "msh",
    Mts = "mts",
    Mxu = "mxu",
    Nc = "nc",
    Oda = "oda",
    Ogg = "ogg",
    Pbm = "pbm",
    Pct = "pct",
    Pdb = "pdb",
    Pdf = "pdf",
    Pgm = "pgm",
    Pgn = "pgn",
    Pic = "pic",
    Pict = "pict",
    Png = "png",
    Pnm = "pnm",
    Pnt = "pnt",
    Pntg = "pntg",
    Ppm = "ppm",
    Ppt = "ppt",
    Pptx = "pptx",
    Potx = "potx",
    Ppsx = "ppsx",
    Ppam = "ppam",
    Pptm = "pptm",
    Potm = "potm",
    Ppsm = "ppsm",
    Ps = "ps",
    Psd = "psd",
    Qt = "qt",
    Qti = "qti",
    Qtif = "qtif",
    Ra = "ra",
    Ram = "ram",
    Ras = "ras",
    Rdf = "rdf",
    Rgb = "rgb",
    Rm = "rm",
    Roff = "roff",
    Rtf = "rtf",
    Rtx = "rtx",
    Sgm = "sgm",
    Sgml = "sgml",
    Sh = "sh",
    Shar = "shar",
    Silo = "silo",
    Sit = "sit",
    Skd = "skd",
    Sketch = "sketch",
    Skm = "skm",
    Skp = "skp",
    Skt = "skt",
    Smi = "smi",
    Smil = "smil",
    Snd = "snd",
    So = "so",
    Spl = "spl",
    Src = "src",
    Sv4cpio = "sv4cpio",
    Sv4crc = "sv4crc",
    Svg = "svg",
    Swf = "swf",
    T = "t",
    Tar = "tar",
    Tcl = "tcl",
    Tex = "tex",
    Texi = "texi",
    Texinfo = "texinfo",
    Tif = "tif",
    Tiff = "tiff",
    Tr = "tr",
    Tsv = "tsv",
    Txt = "txt",
    Ustar = "ustar",
    Vcd = "vcd",
    Vrml = "vrml",
    Vxml = "vxml",
    Wav = "wav",
    Wbmp = "wbmp",
    Wbmxl = "wbmxl",
    Webm = "webm",
    Webp = "webp",
    Wml = "wml",
    Wmlc = "wmlc",
    Wmls = "wmls",
    Wmlsc = "wmlsc",
    Wmv = "wmv",
    Wrl = "wrl",
    Xbm = "xbm",
    Xht = "xht",
    Xhtml = "xhtml",
    Xls = "xls",
    Xml = "xml",
    Xpm = "xpm",
    Xsl = "xsl",
    Xlsx = "xlsx",
    Xltx = "xltx",
    Xlsm = "xlsm",
    Xltm = "xltm",
    Xlam = "xlam",
    Xlsb = "xlsb",
    Xslt = "xslt",
    Xul = "xul",
    Xwd = "xwd",
    Xyz = "xyz",
    Zip = "zip",
    Tpl = "tpl"
}

export declare const FileExtensionSets: Record<keyof typeof FileType, FileExtension[]>;

export declare enum FileType {
    Audio = "audio",
    Documents = "documents",
    Images = "images",
    Videos = "videos",
    Templates = "templates"
}

export declare const generateRandomString: (length?: number) => string;

export declare const getAppBridgeBlockStub: ({ blockSettings, blockAssets, editorState, openAssetChooser, closeAssetChooser, blockId, sectionId, projectId, user, language, privacySettings, blockTemplates, }?: getAppBridgeBlockStubProps) => SinonStubbedInstance<AppBridgeBlock>;

export declare type getAppBridgeBlockStubProps = {
    blockSettings?: Record<string, unknown>;
    blockAssets?: Record<string, Asset[]>;
    editorState?: boolean;
    openAssetChooser?: (callback: Parameters<AppBridgeBlock['openAssetChooser']>[0]) => void;
    closeAssetChooser?: () => void;
    blockId?: number;
    sectionId?: number;
    projectId?: number;
    user?: User;
    language?: string;
    privacySettings?: PrivacySettings;
    blockTemplates?: Record<string, Template[]>;
};

export declare const getAppBridgePlatformAppStub: ({}?: getAppBridgePlatformAppStubProps) => SinonStubbedInstance<AppBridgePlatformApp>;

export declare type getAppBridgePlatformAppStubProps = {};

export declare const getAppBridgeThemeStub: ({ editorState, brandId, portalId, projectId, pageTemplateSettings, pageTemplateAssets, themeSettings, language, openAssetChooser, closeAssetChooser, }?: getAppBridgeThemeStubProps) => SinonStubbedInstance<AppBridgeTheme>;

export declare type getAppBridgeThemeStubProps = {
    editorState?: boolean;
    brandId?: number;
    portalId?: number;
    projectId?: number;
    pageTemplateSettings?: Record<string, unknown>;
    pageTemplateAssets?: Record<string, Asset[]>;
    themeSettings?: Record<string, unknown>;
    language?: string;
    openAssetChooser?: (callback: Parameters<AppBridgeTheme['openAssetChooser']>[0]) => void;
    closeAssetChooser?: () => void;
};

export declare type GetBulkDownloadToken = CamelCasedPropertiesDeep<GetBulkDownloadTokenApi>;

export declare type GetBulkDownloadTokenApi = {
    asset_ids: number[];
    set_ids: number[];
    language: string;
};

declare type GetCurrentUserPayload = void;

declare type GetCurrentUserResponse = {
    id: string;
    name?: string | null;
    avatar?: string | null;
    email: string;
};

export declare const getDatasetByClassName: <T = Record<string, unknown>>(className: string) => T;

export declare const getDatasetByElement: <T = Record<string, unknown>>(element: HTMLElement) => T;

export declare const getMimeType: (filetypes: string[]) => string[];

export declare type GuidelineSearchResult = CamelCasedPropertiesDeep<GuidelineSearchResultApi>;

export declare type GuidelineSearchResultApi = {
    highlights: string[];
    type: 'PAGE' | 'SECTION' | 'BLOCK' | 'COLOR';
    object_id: number;
    page_id: number;
    page_slug: string;
    page_title: string;
    page_category_slug: string | null;
    block_id: number;
    document_id: number;
    document_slug: string;
    document_title: string;
    portal_id: number;
    portal_token: string | null;
};

export declare class GuidelineSearchResultApiDummy {
    static with(query: string): GuidelineSearchResultApi;
}

export declare class GuidelineSearchResultDummy {
    static with(query: string): GuidelineSearchResult;
}

export declare class HttpClient {
    static getCsrfToken(): string | undefined;
    static get<T = DefaultHttpResponse>(url: string): Promise<HttpUtilResponse<T>>;
    static post<T = DefaultHttpResponse>(url: string, data?: Record<never, never>): Promise<HttpUtilResponse<T>>;
    static put<T = DefaultHttpResponse>(url: string, data?: Record<never, never>): Promise<HttpUtilResponse<T>>;
    static patch<T = DefaultHttpResponse>(url: string, data?: Record<never, never>): Promise<HttpUtilResponse<T>>;
    static delete<T = DefaultHttpResponse>(url: string, data?: Record<never, never>): Promise<HttpUtilResponse<T>>;
}

export declare class HttpClientError extends Error {
    code: number;
    responseBody: object;
    constructor(message: string, code: number, responseBody: Record<string, unknown>);
}

export declare type HttpUtilResponse<T> = {
    result: EndpointResponse<T>;
};

export declare class HttpUtilResponseDummy {
    static successWith<T>(data: T): HttpUtilResponse<T>;
    static success(): HttpUtilResponse<undefined>;
    static failure(): HttpUtilResponse<undefined>;
}

export declare const isObject: (item: unknown) => unknown;

export declare enum LinkSettingsDisplay {
    TextAndIcon = "ICON_TEXT",
    IconOnly = "ICON",
    TextOnly = "TEXT"
}

export declare enum LinkSettingsIconPosition {
    Right = "RIGHT",
    Left = "LEFT"
}

export declare enum LinkType {
    External = "EXTERNAL",
    Internal = "INTERNAL"
}

export declare const mergeDeep: <T = Record<string, unknown>>(target: any, ...sources: any) => T;

export declare const mimeTypes: Record<FileExtension, string>;

declare type NameContextList = 'Command' | 'API Method' | 'Event';

export declare function notify<T>(topic: string, token: string, data?: NotifyData<T>, options?: NotifyOptions): void;

export declare type NotifyData<T = Record<string, unknown>> = T;

export declare type NotifyOptions = {
    origin?: string;
};

export declare type OauthTokens = {
    access_token: string;
    refresh_token: string;
    expires_in: number;
    name: string;
    token_type: 'Bearer';
};

declare type ObjectNameValidator<NameObject, PatternObject, NameContext extends NameContextList> = keyof NameObject extends keyof PatternObject ? NameObject : WrongNamePattern<`${Exclude<Extract<keyof NameObject, string>, Extract<keyof PatternObject, string>>}`, NameContext>;

export declare const openAssetChooser: (options?: CommandRegistry['openAssetChooser']) => DispatchHandlerParameter<'openAssetChooser', CommandRegistry>;

declare type OpenAssetChooserPayload = AssetChooserOptions;

export declare const openAssetViewer: ({ token, }: CommandRegistry['openAssetViewer']) => DispatchHandlerParameter<'openAssetViewer', CommandRegistry>;

declare type OpenAssetViewerPayload = {
    token: string;
};

declare type OpenNavigationManager = void;

export declare const openNavigationManager: () => DispatchHandlerParameter<'openNavigationManager', CommandRegistry>;

declare type OpenTemplateChooser = void;

export declare const openTemplateChooser: () => DispatchHandlerParameter<'openTemplateChooser', CommandRegistry>;

declare type Options = {
    /**
     * Whether it should fetch on mount.
     */
    enabled?: boolean;
};

declare type Options_2 = {
    /**
     * Whether it should fetch on mount.
     */
    enabled?: boolean;
};

declare type Options_3 = {
    /**
     * Whether it should fetch on mount.
     */
    enabled?: boolean;
};

declare type Options_4 = {
    /**
     * Whether it should fetch on mount.
     */
    enabled?: boolean;
};

declare type Options_5 = {
    /**
     * Whether it should fetch on mount.
     */
    enabled?: boolean;
};

declare type Options_6 = {
    /**
     * Whether it should fetch on mount.
     */
    enabled?: boolean;
};

declare type Options_7 = {
    /**
     * Whether it should fetch on mount.
     */
    enabled?: boolean;
};

declare type Options_8 = {
    /**
     * Whether it should fetch on mount.
     */
    enabled?: boolean;
};

export declare type PageTemplateAsset = {
    id: number;
    creator: number;
    created: string;
    modifier: Nullable<number>;
    modified: Nullable<string>;
    validTo: Nullable<string>;
    settingId: string;
    assetId: number;
    asset: Asset;
};

export declare type PageTemplateAssetApi = Omit<SnakeCasedPropertiesDeep<PageTemplateAsset>, 'asset'> & {
    asset: AssetApi;
};

export declare type PlatformAppApiMethod = ApiMethodNameValidator<Pick<ApiMethodRegistry, 'getCurrentUser'>>;

export declare type PlatformAppCommand = CommandNameValidator<Record<never, never>>;

export declare type PlatformAppContext = {
    marketplaceServiceAppId: string;
};

export declare type PlatformAppEvent = EventNameValidator<StateAsEventName<PlatformAppState & {
    '*': PlatformAppState;
}> & ContextAsEventName<PlatformAppContext & {
    '*': PlatformAppContext;
}>>;

export declare type PlatformAppState = {
    settings: Record<string, unknown>;
};

export declare type PostExternalAssetParams = {
    title: string;
    url: string;
    previewUrl?: string;
    data?: Record<string, string | undefined>;
};

export declare type PrivacySettings = {
    assetViewerEnabled: boolean;
    assetDownloadEnabled: boolean;
};

export declare type Project = CamelCasedPropertiesDeep<ProjectApi>;

export declare type ProjectApi = {
    id: number;
    created: string;
    creator: number;
    name: string;
    slug: string;
    account: number;
    token: string;
    email_notification: number;
    user_count: number;
    brand_id: number;
    project_type: string;
    auto_tagging_enabled: Nullable<string>;
    date_begin: Nullable<string>;
    date_end: Nullable<string>;
    is_template: number;
    download_sizes: string;
    zoom_level: string;
    success: boolean;
    project: {
        id: number;
        url: string;
        slug: string;
        creator: number;
        creator_name: string;
        creator_initials: string;
        name: string;
        description: Nullable<string>;
        account: number;
    };
};

export declare type ProjectCreate = CamelCasedPropertiesDeep<ProjectCreateApi>;

export declare type ProjectCreateApi = {
    name: string;
    brand: number;
    styleguide: number;
    project_type: DocumentLibraryMode;
};

export declare const rgbObjectToRgbString: (color: {
    red: number;
    green: number;
    blue: number;
    alpha?: number;
}) => string;

export declare const rgbStringToRgbObject: (rgbString: string) => {
    red: number;
    green: number;
    blue: number;
    alpha?: number;
};

export declare type SingleTargetApi = {
    checked: boolean;
    disabled: boolean;
    indeterminate: boolean;
    label: string;
    target: {
        account_id: number;
        asset_ids: unknown[];
        created: string;
        creator: number;
        description: string;
        group_ids: unknown[];
        id: number;
        modified: Nullable<unknown>;
        modifier: Nullable<unknown>;
        name: string;
        sort: number;
        total_groups: Nullable<unknown>;
        total_links: Nullable<unknown>;
        total_users: Nullable<unknown>;
        user_ids: unknown[];
    };
    value: number;
};

export declare class SingleTargetApiDummy {
    static target(value: number): SingleTargetApi;
}

export declare type StateAsEventName<State> = {
    [StateKey in keyof State as StateKey extends string ? `State.${StateKey}` : never]: [
    State[StateKey],
    State[StateKey]
    ];
};

export declare type StateReturn<State, Key> = Key extends keyof State ? {
    /**
     * Gets the current value of the state object at the given key.
     */
    get(): Readonly<State[Key]>;
    /**
     * Sets the value of the state object at the given key.
     * The operation replaces the entire reference.
     */
    set(nextState: State[Key]): void;
    /**
     * Subscribes to changes in the state object at the given key.
     */
    subscribe(callbackFunction: (nextState: State[Key], previousState: State[Key]) => void): EventUnsubscribeFunction;
} : {
    /**
     * Gets the current value of the state object.
     */
    get(): Readonly<State>;
    /**
     * Sets the value of the state object.
     * The operation replaces the entire reference.
     */
    set(nextState: State): void;
    /**
     * Subscribes to changes in the state object.
     */
    subscribe(callbackFunction: (nextState: State, previousState: State) => void): EventUnsubscribeFunction;
};

export declare function subscribe<T>(topic: Topic, token: string, options?: SubscribeOptions): Promise<T>;

export declare const SUBSCRIBE_TIMEOUT: number;

export declare type SubscribeMap<Event> = {
    [EventName in keyof Event as EventName]: Map<EventCallbackParameter<keyof Event, Event>, boolean>;
};

export declare type SubscribeOptions = {
    timeout?: number;
};

export declare type Subscription = keyof SubscriptionCallback;

export declare type SubscriptionCallback = {
    assetsChosen: (selectedAssets: Asset[]) => void;
    templateChosen: (selectedTemplate: TemplateLegacy) => void;
};

export declare type TargetsUpdate = CamelCasedPropertiesDeep<TargetsUpdateApi>;

export declare type TargetsUpdateApi = {
    data: boolean;
    success: boolean;
    targets: number[];
};

export declare type Template = {
    id: number;
    name: string;
    description: string;
    projectId: number;
    previewUrl: string;
    pages: TemplatePage[];
};

export declare type TemplateApiLegacy = {
    asset_created: string;
    asset_modified: string;
    categories: unknown[];
    description: string;
    height: number;
    id: number;
    name: string;
    preview: string;
    project: number;
    project_name: string;
    project_type: string;
    published: number;
    screen_id: number;
    sector: string;
    token: string;
    unit: string;
    width: number;
};

export declare class TemplateApiLegacyDummy {
    static with(id: number): TemplateApiLegacy;
}

export declare type TemplateChooserResult = TemplateApiLegacy;

export declare type TemplateChooserTemplateChosenCallback = (selectedTemplate: {
    template: TemplateChooserResult;
}) => void;

export declare class TemplateDummy {
    static with(id: number): Template;
}

export declare type TemplateLegacy = {
    id: number;
    title: string;
    description: Nullable<string>;
    previewUrl: string;
    projectId: number;
    height: number;
    width: number;
    published: boolean;
};

export declare class TemplateLegacyDummy {
    static with(id: number): TemplateLegacy;
}

export declare type TemplatePage = CamelCasedPropertiesDeep<TemplatePageApi>;

export declare type TemplatePageApi = {
    preview_url: string;
    width: number;
    height: number;
};

export declare type TerrificComponent = {
    component: {
        onAssetChooserAssetChosen: AssetChooserAssetChosenCallback;
        onTemplateChooserTemplateChosen: TemplateChooserTemplateChosenCallback;
    };
};

export declare enum TerrificEvent {
    OpenModal = "onOpenModal",
    CloseModal = "onCloseModal"
}

export declare type ThemeApiMethod = ApiMethodNameValidator<Pick<ApiMethodRegistry, 'getCurrentUser'>>;

export declare type ThemeCommand = CommandNameValidator<Pick<CommandRegistry, 'closeAssetChooser' | 'openAssetChooser' | 'openNavigationManager'>>;

export declare type ThemeContext = {
    portalId: number;
    brandId: number;
};

export declare type ThemeEvent = EventNameValidator<Pick<EventRegistry, 'assetsChosen'> & StateAsEventName<ThemeState & {
    '*': ThemeState;
}> & ContextAsEventName<ThemeContext & {
    '*': ThemeContext;
}>>;

export declare type ThemeState = {
    settings: Record<string, unknown>;
    assets: Record<string, unknown>;
};

export declare class TimeoutReachedError extends Error {
    constructor(topic: string);
}

export declare enum Topic {
    CloseApp = "closeApp",
    DeleteAppState = "deleteAppState",
    GetAppState = "getAppState",
    GetAssetById = "getAssetById",
    GetProjectId = "getProjectId",
    GetRefreshedThirdpartyOauth2Token = "getRefreshedThirdpartyOauth2Token",
    GetThirdPartyOauth2Tokens = "getThirdPartyOauth2Tokens",
    OpenAssetChooser = "openAssetChooser",
    PostExternalAssets = "postExternalAssets",
    PutAppState = "putAppState"
}

export declare class UpdateTargetsApiDummy {
    static with(targetIds: number[]): {
        success: boolean;
        data: boolean;
        targets: number[];
    };
}

export declare class UpdateTargetsDummy {
    static with(targetIds: number[]): {
        success: boolean;
        data: boolean;
        targets: number[];
    };
}

export declare const useAssetChooser: (appBridge: AppBridgeBlock) => UseAssetChooserType;

declare type UseAssetChooserType = {
    openAssetChooser: (callback: (selectedAsset: Asset[]) => void, options: AssetChooserOptions) => void;
    closeAssetChooser: () => void;
};

export declare const useAssetUpload: (props?: UseAssetUploadParameters) => UseAssetUploadReturnTypes;

export declare type UseAssetUploadParameters = {
    onUploadProgress?: (event: MessageEvent) => void;
    onUploadProgressAll?: (event: MessageEvent) => void;
    onUploadDone?: (event: MessageEvent<FileApi>) => void;
    onUploadDoneAll?: (event: Asset[]) => void;
    onUploadFail?: () => void;
    onUploadAssetFail?: (event: MessageEvent) => void;
};

export declare type UseAssetUploadReturnTypes = [(files: FileList | File) => void, {
    results: Asset[];
    doneAll: boolean;
}];

export declare const useAssetViewer: (appBridge: AppBridgeBlock) => {
    open: ({ token }: Asset) => Promise<void>;
};

export declare const useBlockAssets: (appBridge: AppBridgeBlock) => {
    blockAssets: Record<string, Asset[]>;
    addAssetIdsToKey: (key: string, assetIds: number[]) => Promise<void>;
    deleteAssetIdsFromKey: (key: string, assetIds: number[]) => Promise<void>;
    updateAssetIdsFromKey: (key: string, newAssetIds: number[]) => Promise<void>;
};

export declare const useBlockSettings: <T = Record<string, unknown>>(appBridge: AppBridgeBlock) => [T, (newSettings: Partial<T>) => Promise<void>];

export declare const useBlockTemplates: (appBridge: AppBridgeBlock) => {
    blockTemplates: Record<string, Template[]>;
    addTemplateIdsToKey: (key: string, templateIds: number[]) => Promise<void>;
    deleteTemplateIdsFromKey: (key: string, templateIds: number[]) => Promise<void>;
    updateTemplateIdsFromKey: (key: string, newTemplateIds: number[]) => Promise<void>;
};

export declare const useBrandportalLink: (appBridge: AppBridgeTheme, options?: Options) => UseBrandportalLinkReturnType;

export declare type UseBrandportalLinkReturnType = {
    brandportalLink: Nullable<BrandportalLink>;
    isLoading: boolean;
};

export declare const useBulkDownload: (appBridge: AppBridgeBlock) => {
    generateBulkDownload: (assetIds: number[], setIds?: number[]) => Promise<void>;
    status: BulkDownloadState;
    downloadUrl: Nullable<string>;
};

export declare const useCategorizedDocumentPages: (appBridge: AppBridgeBlock | AppBridgeTheme, documentCategoryId: number, options?: Options_2) => {
    documentPages: DocumentPage[];
    refetch: () => Promise<void>;
    isLoading: boolean;
};

export declare const useColorPalettes: (appBridge: AppBridgeBlock, colorPaletteIds?: number[]) => UseColorPalettesReturnType;

export declare type UseColorPalettesReturnType = {
    colorPalettes: ColorPalette[];
    createColorPalette: (colorPaletteCreate: ColorPaletteCreate) => void;
    updateColorPalette: (colorPaletteId: number, colorPalettePatch: ColorPalettePatch) => void;
    deleteColorPalette: (colorPaletteId: number) => void;
    downloadColorKit: (selectedColorPalettes: number[]) => string;
};

export declare const useColors: (appBridge: AppBridgeBlock, colorPaletteId: number) => UseColorsReturnType;

export declare type UseColorsReturnType = {
    colorsByPaletteId: Color[];
    createColor: (colorCreate: ColorCreate) => void;
    updateColor: (colorId: number, colorPatch: ColorPatch) => void;
    deleteColor: (colorId: number) => void;
};

export declare const useCoverPage: (appBridge: AppBridgeTheme, options?: Options_3) => UseCoverPageReturnType;

export declare type UseCoverPageReturnType = {
    coverPage: Nullable<CoverPage>;
    isLoading: boolean;
};

export declare const useDocumentCategories: (appBridge: AppBridgeBlock | AppBridgeTheme, documentId: number, options?: Options_4) => {
    documentCategories: {
        id: number;
        documentId: number;
        slug: string;
        title: string;
        sort: number;
        creator: number;
        created: string;
        modifier: Nullable<string>;
        modified: Nullable<string>;
        validFrom: string;
        validTo: Nullable<string>;
        numberOfDocumentPages: number;
    }[];
    refetch: () => Promise<void>;
    isLoading: boolean;
};

export declare const useDocumentGroups: (appBridge: AppBridgeBlock | AppBridgeTheme, options?: Options_5) => {
    documentGroups: {
        id: number;
        name: string;
        sort: Nullable<number>;
        creator: number;
        created: string;
        modified: Nullable<string>;
        modifier: Nullable<number>;
        validTo: Nullable<string>;
        projectId: number;
        portalId: number;
        numberOfDocuments: number;
    }[];
    refetch: () => Promise<void>;
    isLoading: boolean;
};

export declare const useDocumentPageTargets: (appBridge: AppBridgeBlock | AppBridgeTheme, id: number) => UseDocumentPageTargetsReturnType;

export declare type UseDocumentPageTargetsReturnType = {
    documentPageTargets: Nullable<DocumentPageTargets>;
    isLoading: boolean;
};

export declare const useDocumentSection: (appBridge: AppBridgeBlock | AppBridgeTheme, documentPageId: number) => {
    documentSections: DocumentSection[];
};

export declare const useDocumentTargets: (appBridge: AppBridgeBlock | AppBridgeTheme, id: number) => UseDocumentTargetsReturnType;

export declare type UseDocumentTargetsReturnType = {
    documentTargets: Nullable<DocumentTargets>;
    isLoading: boolean;
};

export declare const useEditorState: (appBridge: AppBridgeBlock | AppBridgeTheme) => boolean;

export declare const useFileInput: ({ accept, multiple }: UseFileInputInterface) => UseFileInputReturnTypes;

export declare type UseFileInputInterface = {
    accept?: string;
    multiple?: boolean;
};

export declare type UseFileInputReturnTypes = [() => void, {
    selectedFiles: FileList | null;
}];

export declare const useFileUpload: (props?: UseFileUploadParameters) => UseFileUploadReturnTypes;

export declare type UseFileUploadParameters = {
    onUploadProgress?: (event: MessageEvent) => void;
    onUploadProgressAll?: (event: MessageEvent) => void;
    onUploadDone?: (event: MessageEvent<FileApi>) => void;
    onUploadDoneAll?: (event: FileApi[]) => void;
    onUploadFail?: () => void;
    onUploadFileFail?: (event: MessageEvent) => void;
};

export declare type UseFileUploadReturnTypes = [(files: FileList | File) => void, {
    results: FileApi[];
    doneAll: boolean;
}];

export declare const useGroupedDocuments: (appBridge: AppBridgeBlock | AppBridgeTheme, documentGroupId: number, options?: Options_6) => {
    documents: Document_2[];
    refetch: () => Promise<void>;
    isLoading: boolean;
};

export declare const useGuidelineActions: (appBridge: AppBridgeTheme) => {
    createLink: (link: DocumentLinkCreate) => Promise<Document_2>;
    updateLink: (link: DocumentLinkUpdate) => Promise<Document_2>;
    deleteLink: (link: DocumentLinkDelete) => Promise<void>;
    createDocumentPage: (documentPage: DocumentPageCreate) => Promise<DocumentPage>;
    updateDocumentPage: (documentPage: DocumentPageUpdate) => Promise<DocumentPage>;
    deleteDocumentPage: (documentPage: DocumentPageDelete) => Promise<void>;
    duplicateDocumentPage: ({ id, documentId, categoryId }: {
        id: number;
        documentId: number;
        categoryId?: number | undefined;
    }) => Promise<{
        id: number;
        linkType: LinkType;
        name: string;
        sections: {}[];
        url: string;
        visibility: DocumentPageVisibility;
    }>;
    moveDocumentPage: (documentPage: {
        id: number;
        documentId: number;
        sort?: Nullable<number> | undefined;
        categoryId?: Nullable<number> | undefined;
    }, documentId: number, position?: number, categoryId?: Nullable<number>) => Promise<void>;
    createLibrary: (library: DocumentLibraryCreate) => Promise<Document_2>;
    updateLibrary: (library: DocumentLibraryUpdate) => Promise<Document_2>;
    deleteLibrary: (library: DocumentLibraryDelete) => Promise<void>;
    createDocumentCategory: (category: DocumentCategoryCreate) => Promise<{
        id: number;
        documentId: number;
        slug: string;
        title: string;
        sort: number;
        creator: number;
        created: string;
        modifier: Nullable<string>;
        modified: Nullable<string>;
        validFrom: string;
        validTo: Nullable<string>;
        numberOfDocumentPages: number;
    }>;
    updateDocumentCategory: (category: DocumentCategoryUpdate) => Promise<void>;
    deleteDocumentCategory: (documentCategory: DocumentCategoryDelete) => Promise<void>;
    moveDocumentCategory: (documentCategory: {
        id: number;
        sort?: Nullable<number>;
    }, documentId: number, position: number) => Promise<void>;
    createCoverPage: (coverPage: CoverPageCreate) => Promise<{
        id: number;
        url: string;
        title: string;
        active: boolean;
        hideInNav: boolean;
        template: CoverPageTemplate;
        documentId: string;
        draft: boolean;
        enabled: boolean;
    }>;
    updateCoverPage: (coverPage: CoverPageUpdate) => Promise<{
        id: number;
        url: string;
        title: string;
        active: boolean;
        hideInNav: boolean;
        template: CoverPageTemplate;
        documentId: string;
        draft: boolean;
        enabled: boolean;
    }>;
    deleteCoverPage: () => Promise<void>;
    updateLegacyCoverPage: (coverPage: Partial<CoverPage>) => Promise<CoverPageUpdateLegacy>;
    moveDocumentGroup: (documentGroup: {
        id: number;
        sort?: Nullable<number>;
    }, position: number) => Promise<void>;
    createDocumentGroup: (documentGroup: DocumentGroupCreate) => Promise<{
        id: number;
        name: string;
        sort: Nullable<number>;
        creator: number;
        created: string;
        modified: Nullable<string>;
        modifier: Nullable<number>;
        validTo: Nullable<string>;
        projectId: number;
        portalId: number;
        numberOfDocuments: number;
    }>;
    updateDocumentGroup: (documentGroupUpdate: DocumentGroupUpdate) => Promise<void>;
    deleteDocumentGroup: (documentGroup: DocumentGroupDelete) => Promise<void>;
    updateBrandportalLink: (brandportalLink: Partial<BrandportalLink>) => Promise<Partial<{
        enabled: boolean;
        label: string;
        url: string;
    }> | null>;
    createDocument: (document: DocumentStandardCreate) => Promise<Document_2>;
    updateDocument: (document: DocumentStandardUpdate) => Promise<Document_2>;
    deleteDocument: (document: DocumentStandardDelete) => Promise<void>;
    moveDocument: (document: {
        id: number;
        sort?: Nullable<number>;
        documentGroupId?: Nullable<number>;
    }, position: number, newGroupId?: number) => Promise<void>;
    updateDocumentPageTargets: (targets: number[], documentPageIds: number[]) => Promise<{
        data: boolean;
        success: boolean;
        targets: number[];
    }>;
    updateDocumentTargets: (targets: number[], documentIds: number[]) => Promise<{
        data: boolean;
        success: boolean;
        targets: number[];
    }>;
};

export declare const useNavigationManager: (appBridge: AppBridgeTheme) => {
    openNavigationManager: () => void;
};

export declare const usePageTemplateSettings: <T = Record<string, unknown>>(appBridge: AppBridgeTheme, template: 'cover' | 'documentPage' | 'library', documentOrDocumentPageId?: number) => {
    pageTemplateSettings: Nullable<T>;
    updatePageTemplateSettings: (pageTemplateSettingsUpdate: Partial<T>) => Promise<void>;
    isLoading: boolean;
};

export declare const usePrivacySettings: (appBridge: AppBridgeBlock) => PrivacySettings;

export declare type User = {
    id: number;
    name: string;
    email: string;
    image: {
        image: string;
        original: string;
        x: string;
        y: string;
        width: string;
        height: string;
    };
    created: string;
    role: string | null;
    language: string;
    timezone: string;
    organization: string;
};

export declare type UserApi = SnakeCasedPropertiesDeep<User>;

export declare class UserApiDummy {
    static with(id: number): UserApi;
}

export declare class UserDummy {
    static with(id: number): User;
}

export declare const useReadyForPrint: (appBridge: AppBridgeBlock) => {
    isReadyForPrint: boolean;
    setIsReadyForPrint: (isReady: boolean) => void;
};

export declare const useTemplateAssets: (appBridge: AppBridgeTheme, template?: 'documentPage' | 'library' | 'cover', documentId?: number, documentPageId?: number) => {
    templateAssets: Record<string, Asset[]>;
    addAssetIdsToKey: (key: string, assetIds: number[]) => Promise<void>;
    deleteAssetIdsFromKey: (key: string, assetIds: number[]) => Promise<void>;
    updateAssetIdsFromKey: (key: string, newAssetIds: number[]) => Promise<void>;
};

export declare const useTemplateChooser: (appBridge: AppBridgeBlock) => UseTemplateChooserType;

declare type UseTemplateChooserType = {
    openTemplateChooser: (callback: (selectedTemplate: TemplateLegacy) => void) => void;
    closeTemplateChooser: () => void;
};

export declare const useThemeAssets: (appBridge: AppBridgeTheme) => {
    themeAssets: Record<string, Asset[]>;
    addAssetIdsToKey: (key: string, assetIds: number[]) => Promise<void>;
    deleteAssetIdsFromKey: (key: string, assetIds: number[]) => Promise<void>;
    updateAssetIdsFromKey: (key: string, newAssetIds: number[]) => Promise<void>;
};

export declare const useThemeSettings: <T = Record<string, unknown>>(appBridge: AppBridgeTheme) => {
    themeSettings: Nullable<T>;
    updateThemeSettings: (themeSettingsUpdate: Partial<T>) => Promise<void>;
    isLoading: boolean;
};

export declare const useUncategorizedDocumentPages: (appBridge: AppBridgeBlock | AppBridgeTheme, documentId: number, options?: Options_7) => {
    documentPages: DocumentPage[];
    refetch: () => Promise<void>;
    isLoading: boolean;
};

export declare const useUngroupedDocuments: (appBridge: AppBridgeBlock | AppBridgeTheme, options?: Options_8) => {
    documents: Document_2[];
    refetch: () => Promise<void>;
    isLoading: boolean;
};

export declare function withAppBridgeBlockStubs<T>(WrappedComponent: ComponentType<T>, appBridgeProps?: getAppBridgeBlockStubProps): [ComponentType<Omit<T, keyof withAppBridgeStubsProps>>, ReturnType<typeof getAppBridgeBlockStub>];

declare type withAppBridgeStubsProps = {
    appBridge: AppBridgeBlock;
};

export declare function withAppBridgeThemeStubs<T>(WrappedComponent: ComponentType<T>, appBridgeProps?: getAppBridgeThemeStubProps): [ComponentType<Omit<T, keyof withAppBridgeThemeStubsProps>>, ReturnType<typeof getAppBridgeThemeStub>];

declare type withAppBridgeThemeStubsProps = {
    appBridge: AppBridgeTheme;
};

declare type WrongNamePattern<ApiMethodName, NameContext extends NameContextList> = ApiMethodName extends string ? `The following ${NameContext} do not match the naming pattern: ${ApiMethodName}` : never;

export { }
