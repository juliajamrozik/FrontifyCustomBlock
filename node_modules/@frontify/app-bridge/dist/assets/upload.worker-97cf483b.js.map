{"version":3,"file":"upload.worker-97cf483b.js","sources":["../src/workers/upload.worker.js"],"sourcesContent":["/* (c) Copyright Frontify Ltd., all rights reserved. */\n\nlet files = [];\nlet filesMetadata = [];\nlet filesMetadataAdd = [];\nlet progress = [];\nlet progressAll = {\n    loaded: 0,\n    total: 0,\n};\nconst uploadChunkQueue = [];\nlet isUploading = false;\n\n// @TODO implement parallel uploads (e.g. 4 workers)\n// @see https://github.com/cinely/mule-uploader/blob/master/src/mule-uploader.js\n\nfunction consumeNextUploadFromQueue() {\n    // Abort early if there is nothing left to do\n    if (uploadChunkQueue.length <= 0) {\n        return;\n    }\n\n    // Start the next pending upload\n    uploadChunkQueue.shift().start();\n}\n\nfunction upload(data, chunk) {\n    const xhr = new XMLHttpRequest();\n\n    try {\n        xhr.upload.onprogress = function (event) {\n            progressAll.loaded += event.loaded - progress[data.index][data.chunk].loaded;\n            progress[data.index][data.chunk].loaded = event.loaded;\n\n            // Calculate loaded bytes of single file considering chunks\n            let loaded = 0;\n\n            // eslint-disable-next-line unicorn/no-array-for-each\n            progress[data.index].forEach((chunkProgress) => {\n                loaded += chunkProgress.loaded;\n            });\n\n            self.postMessage({\n                event: 'onProgress',\n                loaded,\n                total: data.total,\n                lengthComputable: event.lengthComputable,\n                index: data.index,\n            });\n\n            self.postMessage({\n                event: 'onProgressAll',\n                loaded: progressAll.loaded,\n                total: progressAll.total,\n            });\n        };\n    } catch (error) {\n        // IE11 xhr.upload.onprogress seems to be not supported within web-workers\n        // Omit file progress and just send overall progress\n        xhr.onprogress = function (event) {\n            self.postMessage({\n                event: 'onProgressAll',\n                loaded: event.loaded,\n                total: event.total,\n            });\n        };\n    }\n\n    xhr.open('PUT', data.url, true);\n    xhr.onload = function () {\n        progress[data.index][data.chunk].finished = true;\n        let finished = true;\n        for (let p = 1; p < progress[data.index].length; p++) {\n            if (!progress[data.index][p].finished) {\n                finished = false;\n            }\n        }\n\n        if (finished) {\n            files[data.index].finished = true;\n            const xhr2 = new XMLHttpRequest();\n            xhr2.open('POST', `${self.location.origin}/api/file/progress`, true);\n            xhr2.setRequestHeader('content-type', 'application/json');\n            xhr2.onload = function () {\n                let response;\n\n                try {\n                    response = JSON.parse(xhr2.responseText);\n                } catch {\n                    response = {};\n                }\n\n                response.event = 'onDone';\n                response.index = data.index;\n\n                self.postMessage(response);\n\n                // Process next file\n                process();\n            };\n            xhr2.send(JSON.stringify(data));\n        }\n\n        // Start the next chunk upload\n        consumeNextUploadFromQueue();\n    };\n\n    return {\n        start() {\n            xhr.send(chunk);\n        },\n    };\n}\n\nfunction init() {\n    const xhr = new XMLHttpRequest();\n    xhr.open('POST', `${self.location.origin}/api/file/init`, true);\n    xhr.setRequestHeader('content-type', 'application/json');\n    xhr.onload = function () {\n        let response;\n\n        try {\n            response = JSON.parse(xhr.responseText);\n        } catch {\n            response = { success: false };\n        }\n\n        if (!response.success || !(response.files && response.files.length > 0)) {\n            self.postMessage({ event: 'onFail' });\n            return;\n        }\n\n        filesMetadata = filesMetadata.concat(response.files);\n\n        // Only start processing if there are no ongoing uploads\n        if (!isUploading) {\n            isUploading = true;\n            process();\n        }\n    };\n    xhr.send(JSON.stringify({ files: filesMetadataAdd }));\n}\n\nfunction process() {\n    // Sequential upload\n    let found = false;\n    for (let i = 0; i < files.length; i++) {\n        const file = files[i];\n        if (!found && !file.finished) {\n            found = true;\n            processFile(i, files[i], filesMetadata[i]);\n        }\n    }\n\n    if (!found) {\n        // Reset everything after the last upload\n        reset();\n    }\n}\n\nfunction processFile(index, file, fileMetadata) {\n    if (typeof fileMetadata !== 'object') {\n        error(index, file, {});\n        return;\n    }\n\n    if (!fileMetadata.success) {\n        error(index, file, fileMetadata);\n        return;\n    }\n\n    progress[index] = [];\n    const blob = file;\n    const BYTES_PER_CHUNK = 15 * 1024 * 1024;\n    const SIZE = blob.size;\n    let start = 0;\n    let end = BYTES_PER_CHUNK;\n    let chunkNr = 1;\n\n    while (start < SIZE) {\n        const chunk = blob.slice(start, end);\n        progress[index][chunkNr] = { finished: false, loaded: 0 };\n        uploadChunkQueue.push(\n            upload(\n                {\n                    index,\n                    start,\n                    upload: fileMetadata.upload,\n                    object: fileMetadata.object,\n                    url: fileMetadata.upload.urls[chunkNr],\n                    more: end < SIZE,\n                    end: Math.min(end, SIZE - 1),\n                    total: SIZE,\n                    chunk: chunkNr,\n                },\n                chunk,\n            ),\n        );\n        start = end;\n        end = start + BYTES_PER_CHUNK;\n        chunkNr++;\n    }\n\n    // Upload at most 4 chunks in parallel\n    for (let i = 0; i < 4; i++) {\n        consumeNextUploadFromQueue();\n    }\n}\n\nfunction error(index, file, fileMetadata) {\n    const error = fileMetadata?.error ?? 'Unable to process file.';\n\n    self.postMessage({\n        event: 'onFileFail',\n        index,\n        file,\n        file_metadata: fileMetadata,\n        error,\n    });\n\n    isUploading = false;\n    file.finished = true;\n\n    // Process next file\n    process();\n}\n\nfunction reset() {\n    files = [];\n    filesMetadata = [];\n    filesMetadataAdd = [];\n    progress = [];\n    progressAll = {\n        loaded: 0,\n        total: 0,\n    };\n    isUploading = false;\n\n    self.postMessage({\n        event: 'onDoneAll',\n    });\n}\n\nself.onmessage = function (event) {\n    // Allows to add files during ongoing uploads\n    filesMetadataAdd = [];\n\n    for (let index = 0; index < event.data.files.length; index++) {\n        const file = event.data.files[index];\n        let metadata = {\n            name: file.name,\n            size: file.size,\n            type: file.type,\n        };\n\n        if (typeof String.prototype.normalize === 'function') {\n            metadata.name = metadata.name.normalize('NFC');\n        }\n\n        progressAll.total += file.size;\n\n        if (event.data.formData) {\n            metadata = { ...metadata, ...event.data.formData[index] };\n        }\n\n        files.push(file);\n        filesMetadataAdd.push(metadata);\n    }\n\n    init();\n};\n"],"names":["files","filesMetadata","filesMetadataAdd","progress","progressAll","uploadChunkQueue","isUploading","consumeNextUploadFromQueue","upload","data","chunk","xhr","event","loaded","chunkProgress","finished","p","xhr2","response","process","init","found","i","file","processFile","reset","index","fileMetadata","error","blob","BYTES_PER_CHUNK","SIZE","start","end","chunkNr","metadata"],"mappings":"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"}